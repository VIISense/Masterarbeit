\documentclass[a4paper,11pt]{scrartcl}
\usepackage[english]{babel}  % falls der Artikel auf Deutsch verfasst ist
% Verwenden Sie nur EINE der beiden folgenden Zeilen, je nachdem, ob Ihr
% Betriebssystem LATIN1 (=ISO-8859-1) oder UTF8 als Zeichenkodierung
% verwendet. Ob Sie die richtige verwenden, merken Sie daran, dass
% die Umlaute richtig im Dokument dargestellt werden.
\usepackage[utf8]{inputenc}
\usepackage{algorithm,algorithmic} 
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{dsfont}
\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {\itshape}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
\theoremstyle{definition}
\newtheorem{mydef}{Definition}
\newtheorem{mylem}{Lemma}
\newtheorem{mythe}{Theorem}
\newtheorem{mycol}{Corollary}
\newtheorem{mypro}{Proposition}
\newtheorem{ex}{Example}
\usepackage{color}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes,arrows}
\usepackage{verbatim}
\usetikzlibrary{positioning}
\usepackage{ulem}
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}
\usepackage{url}
\makeatletter
\newcommand{\oset}[3][0ex]{%
  \mathrel{\mathop{#3}\limits^{
    \vbox to#1{\kern-2\ex@
    \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother
\begin{document}
\section{Preliminaries}
Let $\mathbf{C}$ be a set of concept names and $\mathbf{R}$ a set of role names such that they are disjoint.
\begin{mydef}[$QFBAPA$]
Let $T$ be a set of symbols
\begin{itemize}
\item set terms over $T$ are:
\begin{itemize}
\item empty set $\emptyset$ and universal set $
\mathcal{U}$
\item every set symbol in $T$
\item if $s,t$ are set terms then also $s\cap t$, $s\cup t$ and $s^{\neg}$
\end{itemize}
\item set constraints over $T$ are
\begin{itemize}
\item $s\subseteq t$ and $s\not\subseteq t$
\item $s=t$ and $s\neq t$
\end{itemize}
where $s,t$ are set terms
\item cardinality terms over $T$ are:
\begin{itemize}
\item every number $n\in \mathbb{N}$
\item $|s|$ if $s$ is a set term
\item if $k,l$ are cardinality terms then also $k+l$ and $n\cdot k$, $n\in \mathbb{N}$
\end{itemize}
\item cardinality constraints over $T$ are:
\begin{itemize}
\item $k=l$ and $k\neq l$
\item $k<l$ and $k\geq l$
\item $k\leq l$ and $k>l$
\item $n$ $dvd$ $k$ and $n$ $\neg dvd$ $k$
\end{itemize}
where $k,l$ are cardinality terms and $n\in\mathbb{N}$
\end{itemize}
For readability we use $\lesseqgtr$ to address the comparison symbols $=,\,\leq,\,\geq,\,<,\,>$. The negation $\not\lesseqgtr$ address the symbols $\neq,\,>,\,<,\,\geq,\,\leq$ respectively.
\end{mydef}
\begin{mydef}[$\mathcal{ALCSCC}$]
Concepts are:
\begin{itemize}
\item all concept names
\item $succ(c)$ if $c$ is a set or cardinality constraint over $\mathcal{ALCSCC}$ concepts and role names
\item if $C,D$ are concepts then:
\begin{itemize}
\item $\neg C$
\item $C\sqcup D$
\item $C\sqcap D$
\end{itemize}
\end{itemize}
\end{mydef}
\begin{mydef}[Negation Normal Form]
A concept is in \textit{negation normal form} ($NNF$) if the negation sign $\neg$ appears only in front of a concept name or above a role name. Let $C$ be a arbitrary concept. Its $NNF$ is obtained by applying the following rules
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $\neg\top$ $\rightarrow$ $\perp$
\item $\neg\perp$ $\rightarrow$ $\top$
\item $\neg\neg C$ $\rightarrow$ $C$
\item $\neg(C\sqcap D)$ $\rightarrow$ $\neg C \sqcup \neg D$
\item $\neg(C\sqcup D)$ $\rightarrow$ $\neg C \sqcap \neg D$
\item $(C)^\neg$ $\rightarrow$ $\neg C$
\item $\neg succ(c)$ $\rightarrow$ $succ(\neg c)$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $\neg (k\lesseqgtr l)$ $\rightarrow$ $k\not\lesseqgtr l$
\item $\neg (n\text{ } dvd \text{ } k)$ $\rightarrow$ $n\text{ } \neg dvd \text{ } k$
\item $\neg (n\text{ } \neg dvd \text{ } k)$ $\rightarrow$ $n\text{ } dvd \text{ } k$
\item $\neg (s_1\subseteq s_2)$ $\rightarrow$ $|s_1\cap s_2^\neg|\geq 1$
\item $(s\cap t)^\neg$ $\rightarrow$ $s^\neg \cup t^\neg$
\item $(s\cup t)^\neg$ $\rightarrow$ $s^\neg \cap t^\neg$
\item $(s^\neg)^\neg$ $\rightarrow$ $s$
\end{itemize}
\end{minipage}
\end{figure}
\end{mydef}
With $NNF(C)$ we denote the concept which is obtained by applying the rules above on $C$ until none is applicable any more.
\begin{mydef}[Positive and Negative Sign]
Let be $(x,y):s$ an assertion. A concept name $C$ or a role name $r$ has a \textit{positive sign} in $s$ if it occurs with no negation sign in front or above it in $s$. It has a \textit{negative sign} otherwise. A concept name $C$ (or a role name $r$) can have both sign in $s$ if $C$ and $\neg C$ (or $r$ and $r^\neg$) are in $s$.
\end{mydef}
an assertion set $S$ is a finite set of assertions of the form $x:C$ and $(x,y):s$, where $C$ is a concept, $s$ a set term and $x,y$ variables. The set $Var(S)$ is the set of variables occurring in $S$.\\
Note that in an assertion in $NNF$ the negation sign can only occurs in front of a concept name and above a role name.
\begin{mydef}[Interpretation]
An \textit{interpretation} $\mathcal{I=(\Delta^\mathcal{I},\cdot^\mathcal{I}},\pi_\mathcal{I})$ over an assertion set $S$ in $\mathcal{ALCSCC}$ consists of a non-empty set $\Delta^\mathcal{I}$, an assignment $\pi_\mathcal{I}$ and a mapping $\cdot^\mathcal{I}$ which maps:
\begin{itemize}
\item $\emptyset$ to $\emptyset^\mathcal{I}$
\item $\mathcal{U}$ to $\mathcal{U}^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item each variable $x\in Var(S)$ to $x^\mathcal{I}\in \Delta^\mathcal{I}$
\item every concept names $A\in\mathbf{C}$ to $A^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item every role name $r\in\mathbf{R}$ to $r^\mathcal{I}\subseteq\Delta^\mathcal{I}\times\Delta^\mathcal{I}$, such that every element in $\Delta^\mathcal{I}$ has a finite number of successors.
\end{itemize}
The set $r^\mathcal{I}(x)$ contains all elements $y$ such that $(x,y)\in r^\mathcal{I}$ e.g. it contains all $r$-successors of $x$.\\
For compound concepts the mapping $\cdot^\mathcal{I}$ is extended inductively as follows
\begin{itemize}
\item $\top^\mathcal{I}=\Delta^\mathcal{I}$ and $\perp^\mathcal{I}=\emptyset^\mathcal{I}$
\item $(C\sqcap D)^\mathcal{I}:=C^\mathcal{I}\cap D^\mathcal{I}$, $(C\sqcup D)^\mathcal{I}:=C^\mathcal{I}\cup D^\mathcal{I}$
\item $(\neg C)^\mathcal{I}:=\Delta^\mathcal{I}\backslash C^\mathcal{I}$
\item $(s\cap t)^\mathcal{I}:= s^\mathcal{I}\cap t^\mathcal{I}$, $(s\cup t)^\mathcal{I}:= s^\mathcal{I}\cup t^\mathcal{I}$
\item $(s^\neg)^\mathcal{I}:=\mathcal{U}^\mathcal{I}\backslash s^\mathcal{I}$
\item $|s|^\mathcal{I}:=|s^\mathcal{I}|$
\item $(k+l)^\mathcal{I}:=(k^\mathcal{I}+l^\mathcal{I})$, $(n\cdot k)^\mathcal{I}:= n\cdot k^\mathcal{I}$
\item $succ(c)^\mathcal{I}=\{x\in \Delta^\mathcal{I}|$the mapping $\cdot^{\mathcal{I}_x}$ satisfies $c\}$
\end{itemize}
The mapping $\cdot^{\mathcal{I}_x}$ maps $\emptyset$ to $\emptyset^\mathcal{I}$, $\mathcal{U}$ to $\mathcal{U}^{\mathcal{I}_x}:=\{\bigcup_{r\in\mathbf{R}}r^\mathcal{I}(x)\}$, every concept $C$ occurring in $c$ to $C^{\mathcal{I}_x}:=C^\mathcal{I}\cap \mathcal{U}^{\mathcal{I}_x}$ and every role name $r$ occurring in $c$ to $r^{\mathcal{I}_x}:=r^\mathcal{I}(x)$.\\
The mappings satisfies for the set terms $s,t$ and the cardinality terms $k,l$
\begin{itemize}
\item $s=t$ iff $s^\mathcal{I}=t^\mathcal{I}$
\item $s\subseteq t$ iff $s^\mathcal{I}\subseteq t^\mathcal{I}$
\item $k\lesseqgtr l$ iff $k^\mathcal{I}\lesseqgtr l^\mathcal{I}$
\item $n\,dvd\,l$ iff $\exists m\in\mathbb{N}:n\cdot m = l^\mathcal{I}$
\end{itemize}
The \textit{assignment} $\pi_\mathcal{I}:Var(S)\rightarrow\Delta^\mathcal{I}$ satisfies
\begin{itemize}
\item $x:C$ iff $\pi_\mathcal{I}(x)\in C^\mathcal{I}$ 
\item $(x,y):s$ iff $(\pi_\mathcal{I}(x),\pi_\mathcal{I}(y))\in s^\mathcal{I}$
\end{itemize} 
$\pi_\mathcal{I}$ satisfies an assertion set $S$ if $\pi_\mathcal{I}$ satisfies every assertion in $S$. If $\pi_\mathcal{I}$ satisfies $S$ then $\mathcal{I}$ is a model of $S$.
\end{mydef}
By the semantic definition $s^\mathcal{I}\cup (s^\neg)^\mathcal{I}=\mathcal{U}^\mathcal{I}$.
\begin{mydef}[Number of successors]
Let $S$ be a set of assertion, $\mathcal{I}$ be an interpretation, $x$ be a variable and $k$ be a cardinality term. The number of successors of $x$ in $k$ in the interpretation $\mathcal{I}$ is denoted by $n_\mathcal{I}(x,k,S):=k^{\mathcal{I}_x}$
where $i,j,l$ are cardinality terms, $n\in\mathbb{N}$ and $s$ is a set term.\\
A assertion regarding a variable $x$ in an interpretation $\mathcal{I}$ is \textit{violated} if
\begin{itemize}
\item $x:succ(k\lesseqgtr n)$ and $n_\mathcal{I}(x,k,S)\not\lesseqgtr n$
\item $x:succ(k\lesseqgtr l)$ and $n_\mathcal{I}(x,k,S)\not\lesseqgtr n_\mathcal{I}(x,l,S)$
\item $x:succ(n\,dvd\,k)$ and $mod(n_\mathcal{I}(x,k,S),n)\neq 0$
\end{itemize} 
where $n\in\mathbb{N}$.
\end{mydef}
\section{Tableau}
A Tableau-algorithm consist of completion rules to decide satisfiability of a set of assertions. The rules are applied exhaustively on the set until none is applicable any more. One major characteristic of this algorithm is that it does not matter in which order the rules are applied. Another characteristic is that it works non-deterministically: In case we have disjunctions we can choose between the concepts in this disjunctions. If a choice ends in a \textit{clash} we track back to the point where we had to chose and take the other choice instead. If all choices ends in a clash then the assertion set is unsatisfiable, otherwise it is satisfiable.
\begin{mydef}[Clash]
An assertion set $S$ contains a \textit{clash} if
\begin{itemize}
\item $\{x:\perp\}\subseteq S$ or
\item $\{x:A,\,x:\neg A\}\subseteq S$ or
\item $\{(x,y):s,\,(x,y):s^\neg\}\subseteq S$
\item $\{x:succ(c)\}\subseteq S$ and $c$ is violated regarding $x$
\end{itemize}
Similar in \cite{1} and \cite{6}, where a variable can be replaced by another variable, we can merge two variables during the Tableau-algorithm.
\begin{mydef}[Merge]
\textit{Merging} $y_1$ and $y_2$ results in one variable $y$: replace all occurrence of $y_1$ and $y_2$ with $y$. 
\end{mydef}
Note that by merging two successors other assertions might become violated:
\begin{align}
S=\{&x:succ(|r\cap A|=1)\sqcap succ(|r\cap B|=1)\sqcap succ(|r|>1),\nonumber\\ &y_1:A, y_2:B, x.r.y_1, x.r.y_2\}
\end{align}
If we merge $y_1$ and $y_2$ then the assertion $x:succ(|r|>1)$ which was satisfied becomes violated.\\
But not only assertions regarding $x$ might become violated after merging two successors of $x$: 
\begin{align}
S=\{&x:succ(|r|\leq 1), x.r.y_1, x.r.y_2,\nonumber
\\&y_1:succ(|s|\leq 1), y_2:succ(|s|\leq 1), y_1.s.z_1, y_2.s.z_2\}
\end{align}
We see that the first assertion is violated and therefore merging $y_1$ and $y_2$ to $y$ would solve the problem but on the other hand the assertion regarding $y$ become violated: 
\begin{align*}
S=\{x:succ(|r|\leq 1), x.r.y,
y:succ(|s|\leq 1), y.s.z_1, y.s.z_2\}
\end{align*}
To solve this problem we have to merge $z_1$ and $z_2$.
\begin{mydef}[Induced Interpretation $\mathcal{I}(S)$]
An interpretation $\mathcal{I}(S)$ can be induced from an assertion set $S$ by the following steps:
\begin{itemize}
\item for each variable $x\in Var(S)$ we introduce $x^{\mathcal{I}(S)}$ and add it to $\Delta^{\mathcal{I}(S)}$
\item for each $x:C$ such that $C$ is a concept name we add $x^{\mathcal{I}(S)}$ to $C^{\mathcal{I}(S)}$
\item for each $(x,y):r$ such that $r$ is a role name we add $(x^{\mathcal{I}(S)},y^{\mathcal{I}(S)})$ to $r^{\mathcal{I}(S)}$
\end{itemize}
With $\mathcal{I}(S)$ we can count how many successors a variable has during the Tableau-algorithm.\\
For the Tableau-algorithm we define the properties of the following notations:
\begin{itemize}
\item Conjunction binds stronger than disjunction: $s\cup t\cap u = s\cup (t\cap u)$
\item if $k,l$ are cardinality terms then $k=l$ replaces $k\leq l$ and $k\geq l$ 
\item if $s,t$ are set terms then $s=t$ replaces $s\subseteq t$ and $s\supseteq t$
\end{itemize}
\end{mydef}
\subsection{Restrictions}
Dealing with $\mathcal{ALCSCC}$ concept is challenging, especially dealing with cardinality constraints. Therefore we restrict cardinality constraint to a more simple form.
\begin{mydef}[$CNNF$]
A constraint is in conjunctive negated normal form $(CNNF)$ if no disjunction appears in a cardinality term.\\
Let $k$ be a cardinality term. Each $|s_1\cup s_2\cup\dots \cup s_n|$ in $k$ is split into
\begin{align*}
&0.\,|s_1\cap s_2\cap\dots \cap s_n|+\\
&1.\,|s_1^\neg\cap s_2\cap\dots \cap s_n|+|s_1\cap s_2^\neg\cap\dots \cap s_n|+\dots +|s_1\cap s_2\cap\dots \cap s_n^\neg|\\
&2.\,|s_1^\neg\cap s_2^\neg\cap\dots \cap s_n|+|s_1^\neg\cap s_2\cap s_3^\neg\dots \cap s_n|+\dots +|s_1\cap s_2\cap\dots s_{n-1}^\neg\cap s_n^\neg|\\
&\dots\\
&n-1.\,|s_1\cap s_2^\neg\cap s_3^\neg\cap\dots \cap s_n^\neg|+|s_1^\neg\cap s_2\cap s_3^\neg\cap\dots \cap s_n^\neg|+\dots +|s_1^\neg\cap s_2^\neg\cap s_3^\neg\cap\dots \cap s_n|
\end{align*}
where in the $1.$-line we have one set term with the negation sign above, in the $2.$-line two set term with the negation sign above and so on.
\end{mydef}
We want to split $|s_1\cup s_2\cup\dots \cup s_n|$ into set terms which are disjoint to each other. This helps to determinate all properties of successors in $k$.\\
We can easily see that the splitting creates exponential more new set terms. To simplify them we omit \textit{unnecessary} set terms. To explain what set terms are unnecessary we look at the following example:
\begin{align*}
S:=\{x:succ(|r\cup s\cup t\cup B|<|r|+|s|)\sqcap succ(|r\cap C|=1)\}
\end{align*}
The first cardinality term $|r\cup s\cup t\cup B|$ in $CNNF$ is split into 15 cardinality terms, which is a high number of terms. The set term $t$ and $B$ is only mentioned once. That means that whether $x$'s successor is a $t$-successor or not it does not bring any further information regarding $x$ and the successor except it is a $t$-successor. The same goes for the information whether the successor is in $B$ or not. Also no assertions can become violated solely by those information. (Note that this algorithm works without a TBox in which axioms regarding $t$ or $B$ may occur and therefore both would be not unnecessary.) On the other hand $r$ is necessary because it appears again in the cardinality term $|r|+|s|$, which describe successors of $x$. For the same reason $s$ is necessary, too. Hence if we omit $t$ and $B$ we do not loose necessary information to conclude more knowledge while reducing the number of split cardinality terms (seven instead of 15).
\begin{mydef}[simplified constraint]
A constraint in $NNF$ in an assertion set $S$ is \textit{simplified} if we omit \textit{unnecessary} set terms from any disjunction.\\
Let $S_x\subseteq S$ be a set of all constraints regarding $x$ in $S$ (e.g. $x:C\in S\rightarrow x:C\in S_x$ and $y:C\in S_x\rightarrow y=x$, $C$ is a concept name and $y$ a variable). A set term $s$ in a constraint $x:succ(s\cup t_1\cup\dots\cup t_n)\in S_x$ is unnecessary and can be omit if it appears syntactically only once in $S_x$.
\end{mydef}
\begin{mydef}[simplified $CNNF$]
A constraint is in \textit{simplified} $CNNF$ if we simplified the constraint first and then convert it to $CNNF$. An assertion set $S$ is in simplified $CNNF$ if all constraints in all assertions are simplified $CNNF$.
\end{mydef}
We consider only simplified $CNNF$ for the algorithm. Also every assertion set raised from the algorithm is converted into simplified $CNNF$.
\subsection{Algorithm}
To maintain readability we write $k\leq l$ instead of $l\geq k$ and $k<l$ instead of $l>k$. Therefore $k\lesseqgtr l$ can only represent $k\leq l$, $k=l$ or $k<l$ from now on.\\
Like in \cite{1} and \cite{6} we have to be \textit{safe} when introducing new variables otherwise we may end in a endless loop or with a false output.\\
Let $x:succ(k\leq l)$ or $x:succ(k<l)$, where $l$ has at least one cardinality term $|s|$, be violated regarding $x$ in an interpretation $\mathcal{I}$. It is \textit{safe} to introduce a new variable $y$ and $S^\prime:=S\cup\{(x,y):l\}$ if 
\begin{align*}
n_\mathcal{I}(x,k,S)-n_\mathcal{I}(x,k,S^\prime)<n_\mathcal{I}(x,l,S)-n_\mathcal{I}(x,l,S^\prime)
\end{align*}
Same goes for $(x,y):k$. This says that it is only safe to add a variable if the number of successor in $l$ increases faster then the number of successors in $k$.
\begin{mydef}[Tableau]
Let $S$ be a set of assertions in simplified $CNNF$.
\begin{enumerate}
\item\label{cap} $\sqcap$-rule: $S$ contains $x:C_1\sqcap C_2$ but not both $x:C_1$ and $x:C_2$\\
$\rightarrow$ $S:=S\cup\{x:C_1, x:C_2\}$
\item\label{cup} $\sqcup$-rule: $S$ contains $x:C_1\sqcup C_2$ but neither $x:C_1$ nor $x:C_2$\\
$\rightarrow$ $S:=S\cup\{x:C_1\}$ or $S:=S\cup\{x:C_2\}$
\item\label{choose}$choose$-rule: $S$ contains $x:succ(k<l)$ or $x:succ(k\leq l)$ and $x$ has a successor $y$ such that for some for some $k^\prime$ in $k$ we have $(x,y):k^\prime\in S$ but $(x,y):k\notin S$\\
$\rightarrow$ either $S:=S\cup\{(x,y):k\}$ or $S:=S\cup\{(x,y):k^\neg\}$
\item\label{chooserole}$choose$-$a$-$role$-rule: $S$ contains $(x,y):s$ but there is no $(x,y):r\notin S$, $r\in\mathbf{R}$, where $r$ has a positive sign in this assertion\\
$\rightarrow$ choose one rule name $r\in\mathbf{R}$, which appears with a negative sign in $s$, and add $(x,y):r$ to $S$
\item\label{setterm}$cardinality_1$-rule: $S$ contains $x:succ(c)$, with $c\in\{k\leq l,\,k<l,\,n\,dvd\,l\}$, such that $c$ is violated in $\mathcal{I}(S)$ regarding $x$. Choose either $i:=k$ or $i:=l$, such that $i$ contains at least one cardinality term $|s|$. If it is safe to add a variable $y$ in $i$:\\
$\rightarrow$ choose a set term $s$, such that $|s|$ is in $i$, and $S:=S\cup\{(x,y):s\}$, then jump to rule \ref{repeat}
\item\label{exceeded}$cardinality_2$-rule: $S$ contains $x:succ(c)$, with $c\in\{k\leq l,\,k<l\}$, which is violated in $\mathcal{I}(S)$ regarding $x$, and $l$ does not contain a set term. If we have two successor $y_1\neq y_2$ of $x$, such that for a set term $s$ in $k$ we have $(x,y_1):s\in S$ and $(x,y_2):s\in S$, and by merging them no satisfied assertion regarding $x$ becomes violated:\\
$\rightarrow$ merge $y_1$ and $y_2$ 
\item\label{s}$set$-rule: $S$ contains $x:succ(s_1\subseteq s_2)$ and $(x,y):s_1$ but not $(x,y):s_2$\\
$\rightarrow$ $S:=S\cup\{(x,y):s_2\}$ and then jump to rule \ref{repeat}
\item\label{repeat} $set.term$-rule (Repeat until inapplicable): In $S$ is $(x,y):s$ and
\begin{enumerate}
\item\label{setterm1} $s=s_1\cap s_2$ but $\{(x,y):s_1,\,(x,y):s_2\}\not\subseteq S$\\
$\rightarrow$ $S:=S\cup \{(x,y):s_1,\,(x,y):s_2\}$ 
\item\label{setterm2} $s=s_1\cup s_2$ and neither $\{(x,y):s_1\}\subseteq S$ nor $S\{(x,y):s_2\}\subset S$\\
$\rightarrow$ either $S:=S\cup \{(x,y):s_1\}$ or $S:=S\cup \{(x,y):s_2\}$ 
\item\label{setterm3} $s=C$ and $y:C\notin S$, where $C$ is an $\mathcal{ALCSCC}$ concepts\\
$\rightarrow$ $S:=S\cup\{y:C\}$
\end{enumerate}
\end{enumerate}
\end{mydef}
Note that:
\begin{itemize}
\item $s$ in \ref{setterm} can also be of the form $t^\neg$.
\item if  $n_1\,dvd\,n_2\cdot l$ and $mod(n_2,n_1)\neq 0$ then $n_1\,dvd\,l$ eventually
\end{itemize}
\end{mydef}
\begin{mydef}[Derived Set]
A \textit{derived set} is an assertion set $S^\prime$ where rule \ref{repeat} is not applicable.
\end{mydef}
The first rule decompose the conjunction and the second rule adds non-deterministically the right assertion. The $choose$-rule is important because we need to know of every successor what kind of role successors they are and in which concepts they are. We use $n_\mathcal{I}(x,k,S)$ to count the successors of $x$ in $k$ which is important for detecting and avoiding violations of assertions. Now there might be a successor $y$ which satisfies only some part of $k$ in the given $S$ such that $n_\mathcal{I}(x,k,S)$ does not count $y$:
\begin{ex}
\begin{align*}
S=\{x:succ(|r\cap s|>1), (x,y):r\}
\end{align*}
\end{ex}
However there might be an interpretation $\mathcal{I^\prime}$ where $y$ is also a $s$-successor of $x$ and hence $n_{\mathcal{I}}(x,k,S)\neq n_{\mathcal{I}^\prime}(x,k,S)$. However the Tableau-algorithm should be able to construct every model of $S$, if $S$ is consistent. Therefore this rule adds non-deterministically either $(x,y):s$ or $(x,y):s^\neg$ which are the only two possibilities.\\
The $choose$-$a$-$role$-rule is necessary because for a assertion $x:succ(c)$ we might have no role name with a positive sign in $c$. Which means we know $x$ must have some successors but we can not decide which role-successor it is. As example we have
\begin{ex}
\begin{align*}
&\mathbf{R}=\{r,s\}\\
&S=\{x:succ(|r^\neg|\geq 1)\}
\end{align*} 
\end{ex}
It states that $x$ have at least one successor which is not a $r$-successor. Since $\mathbf{R}$ only contains $r$ and $s$ we know that the successors must be $s$-successors. First we apply rule \ref{setterm} to actually add a successor. Therefore $y$ is introduced and $(x,y):r^\neg$ is added to $S$. Now no more rules are applicable except for rule \ref{chooserole}. With that rule we can pick either $r$ or $s$. We can not pick $r$ because $r^\neg$ occurs in the assertion. Therefore we have to pick $s$.\\
In the $cardinality_1$-rule we first make a choice whether we take $k$ or $l$ from a cardinality constraints $k\lesseqgtr l$, where the chosen cardinality term has at least a term of the form $|s|$ with $s$ being a set term. Intuitively it would be better to only want to increase $l$ but there are cases, where we have to add a successor in $k$ instead.
\begin{ex}
\begin{align*}
&S=\{x:succ(|s\cap r|+|s\cap r^\neg|+|s^\neg\cap r|<|s|+|r|)\}
\end{align*}
\end{ex}
Note that $|s\cap r|+|s\cap r^\neg|+|s^\neg\cap r|=|s\cup r|$. No matter how often we add a successor in $|r|$ or $|s|$, the left hand side always increases as fast as the right hand side and therefore this assertion stays violated (hence it is not safe). However if we add a successor in $|s\cap r|$ the assertion becomes satisfied. Hence for this example we can choose the $cardinality_1$-rule and choose $i=|s\cap r|+|s\cap r^\neg|+|s^\neg\cap r|$. Then the rule pick one $|s^\ast|$ from $i$ and look whether introducing a new successor $y$ in $s$ is safe. In our case let $s^\ast:=s\cap r$. We know it is save to add this successor because $|s|+||r|$ would increases faster. Therefore $(x,y):s\cap r$ is added to $S$.\\
We consider now two examples to explain the $cardinality_2$-rule.
\begin{ex}
Consider the following example 
\begin{align*}
S=\{x:succ(|r|=1)\sqcap succ(|r\cap s|=1)\sqcap succ=(|r\cap C|=1|)\}
\end{align*}
First by the $\sqcap$-rule we split the whole assertion into three assertions and add them to $S$.\\
By applying the $cardinality_1$-rule and add a new variable $y$ we satisfy at least one assertion but still at least one assertion remains violated. If we apply it a second time to satisfy the remaining assertion(s) then $x:succ(|r|=1)$, which was satisfied before, becomes violated. In case we decided to apply the $cardinality_1$-rule on $x:succ(|r|=1)$ and $x:succ(|r\cap s|=1)$ we have the option of either applying rule the same rule on $x:succ(|r\cap C|=1)$ next or applying the $cardinality_2$-rule on the two introduced variables next. We decide for the first choice:
\begin{figure}[H]
\centering
\begin{tikzpicture}
\node (0) at (0,0) {$x$};
\node (1) at (-4,-2) {$y_1$};
\node (2) at (0,-2) {$y_2$};
\node (3) at (4,-2) {$y_3$};
\node[below = 1mm of 3] {$C$};
\path[->] (0) edge node[above]{$r$} (1);
\path[->] (0) edge node[left]{$r\cap s$} (2);
\path[->] (0) edge node[above]{$r$} (3);
\end{tikzpicture}
\end{figure}
In this case we have to merge three variables: $y_1$, $y_2$ and $y_3$. We can apply the $cardinality_2$-rule here because satisfied assertions regarding $x$ do not become violated. We can also see that the order does not matter: In case we decided for the second choice and merge $y_1$ and $y_2$ to $y$ before introducing $y_3$ we end up with the same results because then we have to merge $y$ and $y_3$.
\begin{figure}[H]
\centering
\begin{tikzpicture}
\node (0) at (0,0) {$x$};
\node (2) at (4,0) {$y$};
\node[below = 1mm of 2] {$C$};
\path[->] (0) edge node[above]{$r\cap s$} (2);
\end{tikzpicture}
\end{figure}
\end{ex}
In the example we see a case where $S$ is unsatisfiable.
\begin{ex}
\begin{align*}
S=\{x:succ(|r|<2)\sqcap succ(|r|\geq 2)\}	
\end{align*}
\end{ex}
First we use the $\sqcap$-rule to split the assertion into two assertions. The assertion $x:succ(|r|<2)$ is satisfied therefore the algorithm tries to fix $x:succ(|r|\geq 2)$. Hence the $cardinality_1$-rule is applied. after that the first assertions remains satisfied but the second one remains violated. Therefore the algorithm applies the $cardinality_1$-rule again on $x:succ(|r|\geq 2)$ which result in $x:succ(|r|<2)$ being violated. To fix this the algorithm tries to apply the $cardinality_2$-rule and tries to merge the two variable. However since $x:succ(|r|\geq 2)$ would become violated the merging is preempted and the algorithm stops with a clash. Since this sequence of rule applications is the only one possible we can say that all possible sequences leads to a clash which means that $S$ in this example is unsatisfiable.\\
The applications of the $set.term$-rules eventually terminates because the number of concept names and role names are finite in $S$ (since $S$ is finite).
\section{Correctness}
For the correctness proof of the Tableau-algorithm we have to show that
\begin{itemize}
\item For every input the Tableau-algorithm terminates
\item If no more rules are applicable on a clash-free assertion set $S$ then $S$ is satisfiable
\item If $S$ is satisfiable then the Tableau-algorithm terminates without a clash
\end{itemize}
First we prove that the tableau algorithm terminates. 
\begin{mypro}
Let $C$ be a concept in simplified $CNNF$. Then there is no infinite chain of applications of any tableau rules issuing from $\{x:C\}$. 
\end{mypro}
To prove this we map any derived set $S$ to an element $\Psi(S)$ from a set $Q$. We then show that the elements in $Q$ can be ordered by a well-founded relation $\prec$. A well-founded relation says that there is no infinite decreasing chain. If we can show that by obtaining a derived set $S^\prime$ from another set $S$ we have $\Psi(S^\prime)\prec\Psi(S)$ then the algorithm terminates.\\
The elements in $Q$ are finite multisets of septuples and the elements of the septuples are either integers or mutlisets of integers. For two septuples $q=(q_1,\dots,q_7)$ and $q^\prime=(q^\prime_1,\dots,q^\prime_7)$ it holds $q\prec q^\prime$ if for the first $i,\, 1\leq i\leq 7$, for which $q_i$ and $q_i^\prime$ differs it holds that $q_i\prec q_i^\prime$ (also called lexicographical ordering). For two mutlisets of integers $q_i$ and $q_i^\prime$ it holds $q_i^\prime\prec q_i$ if $q_i^\prime$ can be obtained from $q_i$ by replacing an integer $c$ in $q_i^\prime$ by a finite number of integers which are all smaller than $c$. The relation $\prec$ for those multisets is well-founded because we work with integers. That means from a multiset $\{0,\,\dots\,,0\}$ we can not obtain a smaller multiset because we would have to replace at least one $0$ with integers which are smaller.\\
For a concept $C$ its size $size(C)$ is inductively defined as
\begin{itemize}
\item $0$, if $C$ is $\perp$
\item $1$, if $C$ is a concept name of $\mathbf{C}$
\item $size(\neg C)= 1+size(C)$
\item $size(succ(c))= 1 + \sum_{C\in\mathbf{C}\text{ in c}} size(C)$
\item $size(C\sqcap D)=size(C\sqcup D)=size(C)+size(D)$
\end{itemize}
The number $n_{sc}(x)$ denotes the number of assertions of the form $x:succ(s_1\subseteq s_2)$ for a variable $x$. Let $y$ be a successor of $x$. The number $n_{sc}(x,y)$ denotes the number of set assertions of the form $x:succ(c_1\subseteq c_2)$ where $(x,y):s_1\in S$ and $(x,y):s_2\in S$ hold.\\
The asymmetrical difference of two numbers $n,m$ is denoted by 
\begin{equation*}
n\unlhd m \begin{cases}
n-m& \text{if } n> m\\
0 & \text{if } n\leq m
\end{cases}
\end{equation*}
The septuples in $Q$ are defined as follows
\begin{mydef}
Let $S$ be an assertion set. The multiset $\Psi(S)$ consist of septuples $\psi_S(x)$ for each variable $x$. The component of the septuples are structured as follows
\begin{itemize}
\item the first component is a non-negative integer $max\{size(C)\mid x:C\in S\}$
\item the second component is a multiset of integers containing for each $x:C\sqcap D$, on which the $\sqcap$-rule is applicable, the non-negative integer $size(C\sqcap D)$ (respectively for $C\sqcup D$)
\item the third component is a multiset which denotes for every $x:succ(k\leq l)$ the integer $n_{\mathcal{I}(S)}(x,k,S)\unlhd n_{\mathcal{I}(S)}(x,l,S)$
\item the fourth component is a multiset of integers in which for each successor $y$ of $x$ we have $n_{sc}(x)-n_{sc}(x,y)$
\item the fifth component denotes the number of all successors of $x$ in $S$
\item the sixth component is a multiset of integers containing for each $x:succ(k\leq n)\in S$ the number of all successors $y$ of $x$ such that we have $(x,y):k^\prime$, $k^\prime$ occurs in $k$ but for at least one $|s|$ in $k$ we have neither $(x,y):s\in S$ nor $(x,y):\neg s\in S$
\item the seventh component saves the difference of the number of all successors and the number of successors $y$ for which there exists a positive role name $r$ such that $(x,y):r\in S$
\end{itemize}
\end{mydef}
\begin{mylem}
The following properties hold
\begin{enumerate}
\item For any concept $C$ we have $size(C)\geq size(NNF(\neg C))$
 \item Any variable $y$ in a derived set $S$ has at most one predecessor $x$ in $S$
\item If $(x,y):r\in S$ for a $r\in\mathbf{R}$ (and $y$ is a introduced variable) then 
\begin{align*}
max\{size(C)\mid x:C\in S\}>max\{size(D)\mid y:D \in S\}
\end{align*}
\end{enumerate}
\end{mylem}
\begin{proof}$ $\\
\vspace*{-5mm}
\begin{enumerate}
\item By induction over the number of applications to compute the negation normal form we have $size(C)=size(NNF(\neg C))$. Because $\neg succ(k\geq0)$ can be replace by $\perp$ which is $smaller$ than $\neg succ(k\geq 0)$, we have $size(C)\geq size(NNF(\neg C))$. This can be done because $\neg succ(k\geq 0)= succ(k<0)$ which is impossible to satisfy and therefore $\neg succ(k\geq 0)=\perp$.
\item If $y$ is a newly introduced variable, then it can only be introduced by exactly one variable $x$ which is $y$'s only predecessor. If two variables are merged together by rule \ref{exceeded} then both variables must have the same predecessor $x$ by the condition of that rule.
\item By the second fact we know that $x$ is the only predecessor of $y$. When $y$ is introduced by applying \ref{setterm} on a assertion $x:succ(k\lesseqgtr l)$ then we have $y:C$ for every concept $C$ occurring in $l$ (for $\neg C$ we have $y:\neg C$). We know that $size(succ(k\lesseqgtr l))$ is greater then $size(C)=:max\{size(D)\mid y:D\in S\}$ therefore Lemma 1.3 holds. A new assertion $y:D$ can occur either because rule \ref{cap} or \ref{cup} are applicable on $y:C$ with $C=D\sqcap D^\prime$ or $C=D\sqcup D^\prime$, which neither raise $max\{size(D)\mid y:D \in S\}$, or because rule \ref{choose} is applicable but that also does not raise $max\{size(D)\mid y:D \in S\}$: If rule \ref{choose} is applicable on $x:succ(k\leq l)$ then for every added assertion $y:D$ the concept $D$ must occur in $k$ and therefore $size(succ(k\leq))>size(D)$. If $y$ gets merged together with another variable $z$, then $y$ and $z$ must have the same predecessor which means that all concept sizes regarding $z$ are also smaller then $max\{size(C)\mid x:C\in S\}$. 
\end{enumerate}
\end{proof}
From the next Lemma we can conclude that the Tableau-algorithm terminates.
\begin{mylem}
If $S^\prime$ is a derived set obtained from the derived set $S$, then $\Psi(S^\prime)\prec\Psi(S)$
\end{mylem}
\begin{proof}
The following proof is sectioned by the definition of obtaining a derived set.
\begin{enumerate}
\item $S^\prime$ is obtained by the application of rule \ref{cap} on $x:C\sqcap D$:\\
The first component remains the same because $size(C)<size(C\sqcup D)$ and $size(D)<size(C\sqcap D)$. The second component decreases because rule \ref{cap} can not be applied on $x:C\sqcap D$ any more meaning that the corresponding entry in the multiset is removed. If $C$ (or $D$) happens to be a disjunction ($C^\prime\sqcup D^\prime$) or a conjunction ($C^\prime\sqcap D^\prime$) then the second component also becomes smaller because $size(C^\prime)$ and $size(D^\prime)$ are always smaller than the disjunction or conjunction of them and therefore also smaller than $size(C\sqcap D)$. Hence the entry for $size(C\sqcap D)$ can be replace by the smaller $size(C^\prime\sqcup D^\prime)$ or $size(C^\prime\sqcap D^\prime)$.\\
Consider now a tuple $\psi_S(y)$ such that $x\neq y$. $\psi_S(y)$ can only be affected if $x$ is a successor of $y$. The first and second component of $\psi_S(y)$ remain unaffected because both are independent from $x$. The third component can decrease but never increase: By adding an assertion for $x$ the number $n_{sc}(y,x)$ might increases and hence the component also might decreases. The fourth, fifth and sixth component also remain unchanged because the number of $y$'s successors does not change. The sixth also do not change because we do not add an assertion of the form $(y,x):s$. Hence $\psi_S(y)$ does not change.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$. 
\item $S^\prime$ is obtained by the application of rule \ref{cup} on $x:C\sqcup D$:\\
similar to above
\item $S^\prime$ is obtained by the application of rule \ref{choose} on $x:succ(k\leq l)$ for a successor $y$ and of rule \ref{s}\\
After rule \ref{choose} we have either $(x,y):s$ or $(x,y):s^\neg$ for all $|s|$ in $k$. Whether it is $(x,y):s$ or $(x,y):s^\neg$ the first two component do not change because we do not add any new assertions regarding $x$. The third and fifth component also does not change because we do not add any new successors for $x$. The fourth component might decreases but never increases: By adding assertions we can only increase the number $n_{sc}(x,y)$ which means that $n_{sc}(x)-n_{sc}(x,y)$ decreases. The sixth component of $\psi_S(x)$ decreases because $y$ does not hold the condition of the fifth component any more.  Hence $\psi_{S^\prime}\prec\psi_S(x)$.\\ 
For any variable $z$ such that $z\neq y$. The tuple $\psi_S(z)$ is unaffected. It can only be affected by the rules if $z$ is a predecessor of $y$. But by Lemma 1.2 that would mean that $z=x$.\\
Because $y$ is a successor of $x$ we know by Lemma 1.3 that the first component of $\psi_{S^\prime}(y)$ is smaller than the first component of $\psi_{S^\prime}(x)$ and therefore $\psi_{S^\prime}(y)\prec\psi_{S^\prime}(x)$. Since the first component of $\psi_{S^\prime}(x)$ does not change we also have $\psi_{S^\prime}(y)\prec\psi_{S}(x)$.\\
We can obtained $\Psi(S^\prime)$ from $\Psi(S)$ by deleting $\psi_S(y)$ and replacing $\psi_S(x)$ by the two smaller septuples $\psi_{S^\prime}(x)$ and $\psi_{S^\prime}(y)$.
\item $S^\prime$ is obtained by the application of rule \ref{chooserole} on $(x,y):s$:\\
The first and second component remains unchanged. Also the third and fifth component because we do not add new successors. The fourth component can decrease but never increase: By adding an assertion $(x,y):r, r\in\mathbf{R}$ we can only increase $n_{sc}(x,y)$ and therefore can only decrease the multiset. With a similar reasoning the sixth component can decrease but never increase. The seventh component always decreases because for a successor $y$ there was no positive role name $r$ such that $(x,y):r$ but afte rthe rule application there is such an assertion. therefore the fifference becomes smaller.\\
Let $z$ be a variable such that $z\neq y$. The element $\psi_S(z)$ can only change if $z$ is a predecessor of $y$. But by Lemma 1.2 that means that $z=x$.\\
We can obtained $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller $\psi_{S^\prime}(x)$.
\item $S^\prime$ is obtained by the application of rule \ref{setterm} on $x:succ(k<l)$, $x:succ(k\leq l)$ or $x:succ(n\,dvd\,l)$ and rule \ref{repeat}:\\ 
For a set term $s$ which occurs as $|s|$ in $l$ we introduce a new variable $y$ and add $(x,y):s$. The first two component of $\psi_S(x)$ remains unchanged. Because we can apply this rule we have $n_{\mathcal{I}(S)}(x,k,S)>n_{\mathcal{I}(S)}(x,l,S)$ and we have no set term $s$ which occurs in $k$ and in $l$ with the same sign. That means that by adding a new successor to $l$ it can never be a successor to $k$, too. Therefore only $n_{\mathcal{I}(S)}(x,l,S)$ increases which means $n_{\mathcal{I}(S)}(x,k,S)\unlhd n_{\mathcal{I}(S)}(x,l,S)$ decreases and hence also the third component.\\
In $S^\prime$ exists now a new tuple $\psi_{S^\prime}(y)$. But since it was introduced by the assertion $x:succ(c)$, $c\in\{k<l,k\leq l,n\,dvd\,l\}$, the first component of it is always smaller then the first component of $\psi_S(x)$.\\
For any variable $z$ such that $z\neq y$. The tuple $\psi_S(z)$ is unaffected. It can only be affected by the rules if $z$ is a predecessor of $y$. But by Lemma 1.2 that would mean that $z=x$.\\
Altogether $\Psi(S^\prime)$ can be obtained from $\Psi(S)$ by replacing $\psi_S(x)$ with the two smaller tuples $\psi_{S^\prime}(x)$ and $\psi_{S^\prime}(y)$.
\item $S^\prime$ is obtained by the application of rule \ref{exceeded} on $x:succ(k<l)$ or $x:succ(k\leq l)$:\\
The first and second component of $\psi_S(x)$ remain unchanged. The third component also remains unchanged: Because we can apply rule \ref{exceeded} we have $l\in\mathbb{N}$ and therefore $n_{\mathcal{I}(S)}(x,k,S)>l$ which means the integer in this multiset is $0$. By merging two successor we have $n_{\mathcal{I}(S)}(x,k,S)\geq n_{\mathcal{I}(S)}(x,l,S)$ which means the asymmetrical difference $n_{\mathcal{I}(S)}(x,k,S)\unlhd  n_{\mathcal{I}(S)}(x,l,S)$ is still $0$. The fourth component can decreases: By merging two successor $y_1, y_2$ the two corresponding entries in the multiset are removed and a new one is added. The new variable $y$ has all assertions of the two successors which means that for some assertions $x:succ(s_1\subseteq s_2)$, such that $(x,y_1):s_1\in S$ and $(x,y_2):s_2\in S$ but $(x,y_1):s_1\not\in S$ and $(x,y_2):s_2\not\in S$, we have after the rule application $(x,y):s_1\in S$ and $(x,y):s_2\in S$ which means that $n_{sc}(x,y)>n_{sc}(x,y_1)$ and $n_{sc}(x,y)>n_{sc}(x,y_2)$. Therefore $n_{sc}(x)-n_{sc}(x,y)$ is smaller than $n_{sc}(x)-n_{sc}(x,y_1)$ or $n_{sc}(x)-n_{sc}(x,y_2)$. The fourth component can not increases because that would mean that by merging two successors we had lost assertions regarding $y_1$ and $y_2$. The fifth component decreases because we have one successor less and therefore $\psi_{S^\prime}(x)$ is smaller than $\psi_S(x)$. The new tuple $\psi_{S^\prime}(y)$ is also smaller than $\psi_S(x)$ because $y$ has the same assertions of the two merged successors whose first component are always smaller than the first component of $\psi_S(x)$ because of Lemma 1.3.\\
No other tuples $\psi_S(z)$ are affected because otherwise $z$ must be a predecessor of $y$ and by Lemma 1.2 $z=x$.\\
Therefore $\Psi(S^\prime)$ can be obtained from $\Psi(S)$ by deleting the tuples of the two merged successors and by replacing $\psi(x)$ with the smaller tuples $\psi_{S^\prime}(x)$ and $\psi_{S^\prime}(y)$.
\item $S^\prime$ is obtained by the application of rule \ref{s} on $x:succ(s_1\subseteq s_2)$ and rule \ref{repeat}:\\ 
After rule \ref{s} $S$ contains $(x,y):s_2$. Then rule \ref{repeat} is applied until inapplicable. After rule \ref{repeat} we can have multiple $(x,y):r$, $r\in\mathbf{R}$, and/or $y:C$. The first and second component do not change. The third component also does not change because we do not add more successors. The fourth component always decreases because the number $n_{sc}(x,y)$ increases. For any $y:C$ $\psi_S(x)$ remains unchanged but we know that the first component of $\psi_S^\prime(y)$ is smaller then the first component of $\psi_S(x)$ by Lemma 1.3.\\
For any variable $z$ such that $z\neq y$ the tuple $\psi_S(z)$ is unaffected. It can only be affected by the rules if $z$ is a predecessor of $y$. But by Lemma 1.2 that would mean that $z=x$.\\
Therefore $\Psi(S^\prime)$ can be obtained from $\Psi(S)$ by deleting $\psi_S(y)$ and by replacing $\psi_S(x)$ with the two smaller septuples $\psi_{S^\prime}(x)$ and $\psi_{S^\prime}(y)$.
\end{enumerate}
\end{proof}
\begin{mylem}
If the Tableau-algorithm terminates without a clash then $S$ is satisfiable
\end{mylem}
\begin{proof}$ $\\
Again the proof is sectioned by the obtained derived sets.\\
Let $\mathcal{I}(S^\prime)$ be the induced interpretation of the assertion set $S^\prime$ created by the Tableau-algorithm from $S$. We show that $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.\\
We start with the simple assertions $x:C$ and $(x,y):r$ for $C\in\mathbf{C}$ and $r\in\mathbf{R}$ (induction base): By the definition of induced interpretation we assign $\pi_{\mathcal{I}(S^\prime)}(x):=x^{\mathcal{I}(S^\prime)}\in C^{\mathcal{I}(S^\prime)}$. Also by the definition of induced interpretation for every $(x,y):r\in S^\prime$ we have $(\pi_{\mathcal{I}(S^\prime)}(x),\pi_{\mathcal{I}(S^\prime)}(y)):=(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})\in r^{\mathcal{I}(S^\prime)}$.\\
Let $S$ be an assertion set and $\pi_{\mathcal{I}(S)}$ be an assignment which satisfies $S$ (induction hypothesis).\par
\begin{enumerate}
\item If we can apply rule \ref{cap} and obtain $S^\prime$ then there must be an assignment $x:C_1\sqcap C_2\in S$. By the definition of induced interpretation and by the hypothesis we already have $\pi_{\mathcal{I}(S^\prime)}(x)\in C_1^{\mathcal{I}(S^\prime)}$ and $\pi_{\mathcal{I}(S^\prime)}(x)\in C_2^{\mathcal{I}(S^\prime)}$. By adding $x:C_1$ and $x:C_2$ we do not change $\mathcal{I}(S)$. Hence $\mathcal{I}(S^\prime):=\mathcal{I}(S)$ and $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{cup} and obtain $S^\prime$ then there must be an assignment $x:C_1\sqcup C_2\in S$. Like above by the definition of the induced interpretation we have $\pi_{\mathcal{I}(S^\prime)}(x):=x^{\mathcal{I}(S^\prime)}$. We also know that $x^{\mathcal{I}(S^\prime)}$ is in $C_1^{\mathcal{I}(S^\prime)}\cup C_2^{\mathcal{I}(S^\prime)}$. By adding either $x:C_1$ or $x:C_2$ we do not change $\mathcal{I}(S)$. Hence $\mathcal{I}(S^\prime):=\mathcal{I}(S)$ and $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{choose} and obtain $S^\prime$ then we have an assertion $x:succ(k\leq l)$ and a successor $y$ such that $(x,y):k^\prime\in S$, $k^\prime$ occurs in $k$. We then choose between $(x,y):s$ and $(x,y):s^\neg$ for all $|s|$ in $k$ then apply rule \ref{repeat} until this rule is inapplicable. That means at the end we might add several assertions of the form $x:C$ and $(x,y):r$. In case we add $x:C$ we also add $x^{\mathcal{I}(S^\prime)}$ to $C^{\mathcal{I}(S^\prime)}$. Therefore in this case $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$. In case we add $(x,y):r$ we also add $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ to $r^{\mathcal{I}(S^\prime)}$. Hence $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{chooserole} and obtain $S^\prime$ then we have an assertion $(x,y):k$ but for every role name $r$ we do not have $(x,y):r\in S$, where $r$ has a positive sign in this assertion. After adding $(x,y):r$, $r\in\mathbf{R}$, to $S^\prime$ the element $(x^{\mathcal{I}(S)},y^{\mathcal{I}(S)})$ is also added to $r^{\mathcal{I}(S^\prime)}$. Hence $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{setterm} and obtain $S^\prime$ then we have an assertion $x:succ(c)$ such that it is violated regarding $x$.\\
We introduce $y$ and add $(x,y):l$ to $S$ and then apply rule \ref{repeat} until this rule is inapplicable. When we introduce $y$ we also add a new element $y^{\mathcal{I}(S^\prime)}$ to $\mathcal{I}(S^\prime)$. For each $y:C$ we add $y^{\mathcal{I}(S^\prime)}$ to $C^{\mathcal{I}(S^\prime)}$ and for each $(x,y):r$, $r\in\mathbf{R}$, we add $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ to $r^{\mathcal{I}(S^\prime)}$. Therefore let $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}\cup \{y\mapsto y^{\mathcal{I}(S^\prime)}\}$.
\item If we can apply rule \ref{setterm} and obtain $S^\prime$ then we have an assertion $x:succ(k<l)$ or $x:succ(k\leq l)$ such that it is violated regarding $x$. We also have two successors $y_1$ and $y_2$ for which $(x,y):s$ and $(x,y):s$ are in $S$.\\
If we merge both together to $y$ we also have to merge $y_1^{\mathcal{I}(S)}$ and $y_2^{\mathcal{I}(S)}$ to one element $y^{\mathcal{I}(S^\prime)}$. For each $y_i:C\in S$, $i\in\{1,2\}$ we have $y_i^{\mathcal{I}(S)}\in C^{\mathcal{I}(S)}$ and for each $(x,y_i):r$, $r\in\mathbf{R}$ we have $(x^{\mathcal{I}_S},y_i^{\mathcal{I}(S)})\in r^{\mathcal{I}(S)}$ due to the hypothesis. That means that by merging both elements the element $y^{\mathcal{I}(S^\prime)}$ must be in $C^{\mathcal{I}(S^\prime)}$ for every $y_i^{\mathcal{I}(S)}\in C^{\mathcal{I}(S)}$ and the element $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ must be in $r^{\mathcal{I}(S^\prime)}$ for every $(x^{\mathcal{I}(S)},y_i^{\mathcal{I}(S)})\in r^{\mathcal{I}(S)}$. Therefore let $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}\backslash\{y_1\mapsto y_1^{\mathcal{I}(S)}, y_2\mapsto y_2^{\mathcal{I}(S)}\}\cup\{y\mapsto y^{\mathcal{I}(S)}\}$ which satisfies $S^\prime$.
\item If we can apply rule \ref{s} and obtain $S^\prime$ then we have an assertion $x:succ(c_1\subseteq c_2)$ and a successor $y$ such that $(x,y):c_1\in S$ but $(x,y):c_2\notin S$. By adding $(x,y):c_2$ to $S$ we have also to add $y:C$ for every concept $C$ in $c_2$ and $(x,y):r$ for every role name $r$ in $c_2$. That means that $x^{\mathcal{I}(S)}$ is added to every $C^{\mathcal{I}(S)}$ and that $(x^{\mathcal{I}(S)},x^{\mathcal{I}(S)})$ is added to every $r^{\mathcal{I}(S)}$. Therefore the assignment $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\end{enumerate}
\end{proof}
\begin{mylem}
If $S$ is satisfiable then the Tableau-algorithm terminates without a clash.
\end{mylem}
\begin{proof}
\end{proof}
\normalem
\bibliographystyle{abbrv}
\bibliography{ref}
\end{document}
