\documentclass[a4paper,11pt]{scrartcl}
\usepackage[english]{babel}  % falls der Artikel auf Deutsch verfasst ist
% Verwenden Sie nur EINE der beiden folgenden Zeilen, je nachdem, ob Ihr
% Betriebssystem LATIN1 (=ISO-8859-1) oder UTF8 als Zeichenkodierung
% verwendet. Ob Sie die richtige verwenden, merken Sie daran, dass
% die Umlaute richtig im Dokument dargestellt werden.
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{dsfont}
\usepackage{float}
\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {\itshape}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
\theoremstyle{definition}
\newtheorem{mydef}{Definition}
\newtheorem{mylem}{Lemma}
\newtheorem{mythe}{Theorem}
\newtheorem{mycol}{Corollary}
\newtheorem{mypro}{Proposition}
\newtheorem{ex}{Example}
\usepackage{color}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes,arrows}
\usepackage{verbatim}
\usetikzlibrary{positioning}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{pgfplots}
\pgfplotsset{compat=1.8}
\usetikzlibrary{patterns}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\usepackage{ulem}
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}
\usepackage{url}
\makeatletter
\newcommand{\oset}[3][0ex]{%
  \mathrel{\mathop{#3}\limits^{
    \vbox to#1{\kern-2\ex@
    \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother
\pgfplotsset{
    standard/.style={
        axis x line=middle,
        axis y line=middle,
        enlarge x limits=0.1,
        enlarge y limits=0.15,
        every axis x label/.style={at={(current axis.right of origin)},anchor= north west},
        every axis y label/.style={at={(current axis.above origin)},anchor= east}
    }
}
\begin{document}
\tableofcontents
\newpage
\section{Introduction}
Traditional data bases where data are stored solely without any connection towards to themselves like many people would imagine are often not enough any more. The reason is that the data are stored without any semantics. However storing data with semantics can provide additional information. For example we have some data about two objects \textit{"Anna"} and \textit{"Beth"}. In a traditional data base if not explicitly stated, both data are not related to each other. Nethertheless Anna and Beth can have a relation, which also depends on who or what both are. For example both can be human and Anna is a teacher and Beth is a student. Both are in the same class. By adding solely those information in a traditional data base the information that Anna must teaches Beth is not given. One way to apply semantics to data objects is to use \textit{ontologies}. In biological and (bio)medical researches data bases are often based on ontologies \cite{bio}. Ontologies (in the computer science field) can be viewed as formal representation of a certain domain of interest. In data base they are collection of relation between the entities in the data base and are formulated as a fragment of first-order logic (FOL). These fragments of FOL are represented as \textit{Description Logic (DL)}, which is a family of knowledge representation system. DL are mainly built of concepts, which correspond to unary relations in FOL and is often represented by a capital letter, and relation between the concepts, which correspond to binary relations in FOL and is often represented by a lowercase letter. For more complex (compound) concepts operators like $\sqcap$, $\sqcup$,$\sqsubseteq$, $\exists$ and $\forall$, depending on the DL, are used. For example the statement "All Men and Women are Human" is formalize in FOL as $\forall x.Men(x)\vee Women(x)\rightarrow Human(x)$ and in DL as an \textit{axiom} $Men\,\sqcup\, Women\sqsubseteq Human$, where $Men$,$Women$ and $Human$ are concept names. The statement "All Humans, who have children, are parents" can be formalized in FOL as $\forall x \exists y. Human(x)\wedge hasChildren(x,y)\rightarrow Parent(x)$ and in DL as $Human\sqcap \exists hasChildren.\top \sqsubseteq Parent$, where $Human$ and $Parents$ are concept names and $hasChildren$ is a role name. Restriction with the operators $\exists$ and $\forall$ are called \textit{quantified} restrictions. The second statement can also be formalized with a \textit{qualified} restriction: $Human\sqcap \geq 1 hasChildren.\top\sqsubseteq Parent$. Each quantified restriction can be transformed into a qualified restriction.\\
One big research field in DL is the determination of satisfiability of an \textit{knowledge base}, which is formulated in DL. A knowledge base normaly consists of a \textit{TBox}, which contains the axioms (rules), and of an \textit{ABox} which contains assertions of certain elements (objects). This DL allows conjunctions ($\sqcap$), disjunctions ($\sqcup$), negation $\neg C$ and qualifying number restriction ($\leq\,n\,r\, C$ and $\geq \, n\, r\, C$), where $n$ is a number, $r$ a role name, and $C$ a concept name. In \cite{1} a \textit{Tableau}-algorithm is presented for checking satisfiability for an ABox in the DL $\mathcal{ALCQ}$. A Tableau-algorithm applies \textit{completion rules} to a given \textit{set}(ABox) to decompose complex concepts and try satisfiying violated \textit{statements}(assertions). If the set concludes something unsatisfiable (clash) then the whole set is unsatisfiable. If no more rules are applicable and the set is not unsatisfiable, then it is otherwise. The satisfiability (of concepts) is stated in \cite{1} as PSPACE-hard problem (without TBox, with TBox it is EXPTime-hard \cite{4}. In \cite{pspace} a optimized Tableau-algorithm is presented which results in a PSPACE-problem. The optimization is that instead of keeping $n$ successors to satisfy a restriction $\geq\,n\,r.C$ like in \cite{1}, the algorithm saves the number of existing successors and by comparing the numbers detects possible clashes. This DL is more expressive than $\mathcal{ALCQ}$ because every qualified restriction $\leq\,n\,r.C$ and $\geq \, n\, r.C$ can be written in $\mathcal{ALCSCC}$ as $succ(|r.C|\leq 1)$ and $succ(|r.C|\geq 1)$. \\
The expressive DL $\mathcal{ALCSCC}$ extends $\mathcal{ALCQ}$ with \textit{set constraint} and \textit{cardinality constrant}, which lays under the logic of \textit{QFBAPA} (quantifier-free fragment of Boolean Algebra with Presburger Arithmetic). As the name says we do not have quantifier. Instead we use set expression (Boolean Algebra part) and numerical constraint (Presburger Arithmetic) which is combined together with cardinality functions. For example $Human\sqcap \geq 1\,hasChildren.\top\sqsubseteq Parent$ is written in $\mathcal{ALCSCC}$ as $Human\sqcap succ(|hasChildren|\geq 1)\sqsubseteq Parent$. In \cite{4} a solution for the satisfiability problem (without TBox) is presented which has the complexity PSpace: For an ABox we guess the value (true or false) of the top-level variables which can already lead to a \textit{false}-result. If not then the constraint is formulated into a $QFBAPA$ formula, for which an algorithm determine by guessing a number $N$ of Venn-region to be non-empty whether the formula is satisfied or not.\\
In this work we give another solution for the satisfiability problem with a Tableau-algorithm. As in previous work for other DLs we define completion rules which can be applied onto assertions in the ABox to determine whether $\perp$ can be concluded from it which states its unsatisfiability. If we can not apply any rules any more and we can not conclude $\perp$, then the ABox is satisfiable. The main difficulty is that unlike $\mathcal{ALCQ}$, where the bond of number of successor is fixed, in $\mathcal{ALCSCC}$ we can compare two cardinalities, which can vary during the algorithm. Hence we need an approach for counting successors and with it calculating the \textit{correct} cardinality, which is necessary to detect satisfied and violated constraint. For this we introduce \textit{induced interpretation} which can determine the cardinalities after each rule application. We want to make sure, that the variation of the cardinalities are in our favour and hence \textit{block} certain assertion from adding into the ABox. To determine which assertion needs to be blocked we apply the satisfiability algorithm from \cite{4}.
\section{Preliminaries}
In this work $\mathbf{C}$ denotes a set of concept names and $\mathbf{R}$ a set of role names, which are disjoint. Before we define the DL $\mathcal{ALCSCC}$ we have to explain first how the language $QFBAPA$ looks like.
\begin{mydef}[$QFBAPA$]
Let $T$ be a set of symbols
\begin{itemize}
\item set terms over $T$ are:
\begin{itemize}
\item empty set $\emptyset$ and universal set $
\mathcal{U}$
\item every set symbol in $T$
\item if $s,t$ are set terms then also $s\cap t$, $s\cup t$ and $s^{\neg}$
\end{itemize}
\item set constraints over $T$ are
\begin{itemize}
\item $s\subseteq t$ and $s\not\subseteq t$
\item $s=t$ and $s\neq t$
\end{itemize}
where $s,t$ are set terms
\item cardinality terms over $T$ are:
\begin{itemize}
\item every number $n\in \mathbb{N}$
\item $|s|$ if $s$ is a set term
\item if $k,l$ are cardinality terms then also $k+l$ and $n\cdot k$, $n\in \mathbb{N}$
\end{itemize}
\item cardinality constraints over $T$ are:
\begin{itemize}
\item $k=l$ and $k\neq l$
\item $k<l$ and $k\geq l$
\item $k\leq l$ and $k>l$
\item $n$ $dvd$ $k$ and $n$ $\neg dvd$ $k$
\end{itemize}
where $k,l$ are cardinality terms and $n\in\mathbb{N}$
\end{itemize}
\end{mydef}
Since $s\subseteq t$ can be expressed as the cardinality constraint $|s\cap t^\neg|\leq 0$ we will not consider any set constraints further in this work. In case we want to express $x:succ(s=t)$, with $s,t$ being set terms, we write instead $x:succ(|s\cap t^\neg|\leq 0)\sqcap succ(|s^\neg\cap t|\leq 0)$. Furthermore instead of $l\geq k$ we write $k\leq l$, instead of $k<l$ we write $k+1\leq l$ and instead of $k=l$ we write $k\leq l$ and $l\leq k$. Hence for an assertion $x:succ(c)$ the cardinality constraint $c$ is either of the form $k\leq l$ or $n\,dvd\,l$.
\begin{mydef}[$\mathcal{ALCSCC}$]
$\mathcal{ALCSCC}$ concepts are defined inductively:
\begin{itemize}
\item all concept names
\item $succ(c)$ if $c$ is a cardinality constraint over $\mathcal{ALCSCC}$ concepts and role names
\item if $C,D$ are concepts then:
\begin{itemize}
\item $\neg C$
\item $C\sqcup D$
\item $C\sqcap D$
\end{itemize}
\end{itemize}
\end{mydef}
An ABox $S$ in $\mathcal{ALCSCC}$ is a finite set of assertions of the form $x:C$ and $(x,y):s$, where $C$ is a $\mathcal{ALSCSS}$ concept, $s$ a set term and $x,y$ variables. The set $Var(S)$ is the set of variables occurring in $S$. 
\begin{mydef}[Interpretation]
An \textit{interpretation} $\mathcal{I}=(\Delta^\mathcal{I},\cdot^\mathcal{I},\pi_\mathcal{I})$ over an ABox $S$ in $\mathcal{ALCSCC}$ consists of a non-empty set $\Delta^\mathcal{I}$, an assignment $\pi_\mathcal{I}$ and a mapping $\cdot^\mathcal{I}$ which maps:
\begin{itemize}
\item $\emptyset$ to $\emptyset^\mathcal{I}$
\item $\mathcal{U}$ to $\mathcal{U}^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item each variable $x\in Var(S)$ to $x^\mathcal{I}\in \Delta^\mathcal{I}$
\item every concept names $A\in\mathbf{C}$ to $A^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item every role name $r\in\mathbf{R}$ to $r^\mathcal{I}\subseteq\Delta^\mathcal{I}\times\Delta^\mathcal{I}$, such that every element in $\Delta^\mathcal{I}$ has a finite number of successors.
\end{itemize}
The set $r^\mathcal{I}(x)$ contains all elements $y$ such that $(x,y)\in r^\mathcal{I}$ e.g. it contains all $r$-successors of $x$.\\
For compound concepts the mapping $\cdot^\mathcal{I}$ is extended inductively as follows
\begin{itemize}
\item $\top^\mathcal{I}=\Delta^\mathcal{I}$ and $\perp^\mathcal{I}=\emptyset^\mathcal{I}$
\item $(C\sqcap D)^\mathcal{I}:=C^\mathcal{I}\cap D^\mathcal{I}$, $(C\sqcup D)^\mathcal{I}:=C^\mathcal{I}\cup D^\mathcal{I}$
\item $(\neg C)^\mathcal{I}:=\Delta^\mathcal{I}\backslash C^\mathcal{I}$
\item $(s\cap t)^\mathcal{I}:= s^\mathcal{I}\cap t^\mathcal{I}$, $(s\cup t)^\mathcal{I}:= s^\mathcal{I}\cup t^\mathcal{I}$
\item $(s^\neg)^\mathcal{I}:=\mathcal{U}^\mathcal{I}\backslash s^\mathcal{I}$
\item $|s|^\mathcal{I}:=|s^\mathcal{I}|$
\item $(k+l)^\mathcal{I}:=(k^\mathcal{I}+l^\mathcal{I})$, $(n\cdot k)^\mathcal{I}:= n\cdot k^\mathcal{I}$
\item $succ(c)^\mathcal{I}=\{x\in \Delta^\mathcal{I}|$the mapping $\cdot^{\mathcal{I}_x}$ satisfies $c\}$
\end{itemize}
The mapping $\cdot^{\mathcal{I}_x}$ maps $\emptyset$ to $\emptyset^\mathcal{I}$, $\mathcal{U}$ to $\mathcal{U}^{\mathcal{I}_x}:=\{\bigcup_{r\in\mathbf{R}}r^\mathcal{I}(x)\}$, every concept $C$ occurring in $c$ to $C^{\mathcal{I}_x}:=C^\mathcal{I}\cap \mathcal{U}^{\mathcal{I}_x}$ and every role name $r$ occurring in $c$ to $r^{\mathcal{I}_x}:=r^\mathcal{I}(x)$.\\
The mappings satisfies for the cardinality terms $k,l$
\begin{itemize}
\item $k\leq l$ iff $k^\mathcal{I}\leq l^\mathcal{I}$
\item $n\,dvd\,l$ iff $\exists m\in\mathbb{N}:n\cdot m = l^\mathcal{I}$
\end{itemize}
The \textit{assignment} $\pi_\mathcal{I}:Var(S)\rightarrow\Delta^\mathcal{I}$ satisfies
\begin{itemize}
\item $x:C$ iff $\pi_\mathcal{I}(x)\in C^\mathcal{I}$ 
\item $(x,y):s$ iff $(\pi_\mathcal{I}(x),\pi_\mathcal{I}(y))\in s^\mathcal{I}$
\end{itemize} 
$\pi_\mathcal{I}$ satisfies an ABox $S$ if $\pi_\mathcal{I}$ satisfies every assertion in $S$. If $\pi_\mathcal{I}$ satisfies $S$ then $\mathcal{I}$ is a model of $S$.
\end{mydef}
We say a set term $t$ occurs semantically in a cardinality term $k=n_0+n_1\cdot |s_1|+\dots +n_j\cdot|s_j|$ if for a $i\in\{1,\dots ,j\}$ we have $s_i=t\cup t_{rest}$, where $t_{rest}$ is a set term. Note that a set term $t$ does not occurs semantically in the cardinality term$|t^\neg|$.\\
For the Tableau-algorithm we can apply rules for decomposing concepts, introducing variables, adding assertion and merging variables.
\begin{mydef}[Merge]
\textit{Merging} two variables $y_1$ and $y_2$ in an ABox $S$ results in one variable $y$: replace all occurrence of $y_1$ and $y_2$ with $y$ in $S$. 
\end{mydef}
\section{Prearrangement}
A Tableau-algorithm consist of completion rules to decide satisfiability of a set of assertions. The rules are applied exhaustively on the set until none is applicable any more. One major characteristic of this algorithm is that it does not matter in which order the rules are applied. Another characteristic is that it works non-deterministically: In case we have disjunctions we can choose between the concepts in this disjunctions. If a choice ends in a \textit{clash} then we track back to the point where we had to chose and take the other choice instead. If all choices ends in a clash then the ABox is unsatisfiable, otherwise it is satisfiable.\\
To help the algorithm we want to avoid nested negation e.g. $\neg(\neg(\neg(A\cup B)))$. Hence we consider all concepts in \textit{negated normal form (NNF)}.
\begin{mydef}[Negation Normal Form]
A $\mathcal{ALCSCC}$ concept is in \textit{negation normal form} ($NNF$) if the negation sign $\neg$ appears only in front of a concept name or above a role name. Let $C$ be a arbitrary $\mathcal{ALCSCC}$ concept. With $NNF(C)$ we denote the concept which is obtained by applying the rules below on $C$ until none is applicable any more.
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $\neg\top$ $\rightarrow$ $\perp$
\item $\neg\perp$ $\rightarrow$ $\top$
\item $\neg\neg C$ $\rightarrow$ $C$
\item $\neg(C\sqcap D)$ $\rightarrow$ $\neg C \sqcup \neg D$
\item $\neg(C\sqcup D)$ $\rightarrow$ $\neg C \sqcap \neg D$
\item $C^\neg$ $\rightarrow$ $\neg C$
\item $\neg succ(c)$ $\rightarrow$ $succ(\neg c)$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $\neg (k\leq l)$ $\rightarrow$ $l\leq k$
\item $\neg (n\text{ } dvd \text{ } k)$ $\rightarrow$ $n\text{ } \neg dvd \text{ } k$
\item $\neg (n\text{ } \neg dvd \text{ } k)$ $\rightarrow$ $n\text{ } dvd \text{ } k$
\item $(s\cap t)^\neg$ $\rightarrow$ $s^\neg \cup t^\neg$
\item $(s\cup t)^\neg$ $\rightarrow$ $s^\neg \cap t^\neg$
\item $(s^\neg)^\neg$ $\rightarrow$ $s$
\end{itemize}
\end{minipage}
\end{figure}
\end{mydef}
The rule $C^\neg\rightarrow \neg C$ is necessary because $C^\neg$ can be a result of $s^\neg$, where $s$ is a set term. It can be transformed into $\neg C$: For every interpretation $\mathcal{I}$ of $S$ we have $(C^\neg)^\mathcal{I}=\mathcal{U}\backslash C^\mathcal{I}$ and $(\neg C)^\mathcal{I}=\Delta^\mathcal{I}\backslash C^\mathcal{I}$. Since $\mathcal{U}\subseteq \Delta$ we can conclude that every element in $(C^\neg)^\mathcal{I}$ is also in $(\neg C)^\mathcal{I}$.\\
The first five rules on the left hand side can be applied in linear time \cite{1},\cite{6}. The first four rules on the right hand side, $C^\neg\rightarrow \neg C$ and $\neg succ(c)\rightarrow succ(\neg c)$ can also be applied in linear time since we only shift the negation sign. the rule $(s^\neg)^\neg\rightarrow s$ works similarly to $\neg\neg C\rightarrow C$ and the rules $(s\cap t)^\neg\rightarrow s^\neg\cup t^\neg$ and $(s\cup t)^\neg\rightarrow s^\neg \cap t^\neg$ works the similarly to $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and can also be applied in linear time.\\
Next we introduce \textit{induced interpretation} with which we can count successors of variables after any rule application.
\begin{mydef}[Induced Interpretation]
An interpretation $\mathcal{I}(S)$ can be induced from an ABox $S$ by the following steps:
\begin{itemize}
\item for each variable $x\in Var(S)$ we introduce $x^{\mathcal{I}(S)}$ and add it to $\Delta^{\mathcal{I}(S)}$
\item for each $x:C$ such that $C$ is a concept name we add $x^{\mathcal{I}(S)}$ to $C^{\mathcal{I}(S)}$
\item for each $(x,y):r$ such that $r$ is a role name we add $(x^{\mathcal{I}(S)},y^{\mathcal{I}(S)})$ to $r^{\mathcal{I}(S)}$
\end{itemize}
\end{mydef}
Since we can now denote the number of successor of a variable $x$ we can determine which assertion of the form $x:succ(c)$ are violated.
\begin{mydef}[Violated assertion]
Let $S$ be a set of assertion, $x$ be a variable, $k$ be a cardinality term and $n\in\mathbb{N}$. An assertion is \textit{violated} if
\begin{itemize}
\item $x:succ(n\leq l)$ and $n\not\leq l^{\mathcal{I}(S)_x}$
\item $x:succ(k\leq n)$ and $k^{\mathcal{I}(S)_x}\not\leq n$
\item $x:succ(k\leq l)$ and $k^{\mathcal{I}(S)_x}\not\leq l^{\mathcal{I}(S)_x}$
\item $x:succ(n\,dvd\,k)$ and $mod(k^{\mathcal{I}(S)_x},n)\neq 0$
\end{itemize} 
where $n\in\mathbb{N}$.
\end{mydef}
Like already mentioned an ABox is unsatisfiable if all choices ends in a clash. A clash in a ABox $S$ implies that $\perp$ can be derived from $S$.
\begin{mydef}[Clash]
An ABox $S$ contains a \textit{clash} if
\begin{itemize}
\item $\{x:\perp\}\subseteq S$ or
\item $\{x:A,\,x:\neg A\}\subseteq S$ or
\item $\{x:succ(n\,\neg dvd\,l),x:succ(m\,dvd\,l)\}\subseteq S$, with $n\,dvd\,m$ or $m\,dvd\,n$, or
\item $\{(x,y):s,\,(x,y):s^\neg\}\subseteq S$ or
\item $\{x:succ(c)\}\subseteq S$ violated and no more rules are applicable
\end{itemize}
\end{mydef}
\subsection{The form of the ABox}
Like already mention a ABox $S$ in $\mathcal{ALCSCC}$ contains assertions of the form $x:C$ and $(x,y):C$ where $C$ is a $\mathcal{ALCSCC}$ concept and $x,y\in Var(S)$ are variables. Like already discussed we want constraints to be in $NNF$ and for an assertion $x:succ(c)$ that $c$ is either $k\leq l$ or $n\,dvd\,l$.
Our desired form for the ABox is gained by the following algorithm.
\begin{algorithm}[H] \caption{Transforming ABox}
\begin{algorithmic}[l]
\State ABox $S$
\ForEach {assertion $x:succ(c)\in S$}
\If {$c$ is $s_1\subseteq s_2$}
\State $c:=|s_1\cap s_2^\neg|\leq 0$; return;
\EndIf
\If{$c$ is $s_1\supseteq s_2$ and a set term constraint}
\State $c:=|s_1^\neg\cap s_2|\leq 0$; return;
\EndIf
\If{$c$ is $s_1=s_2$}
\State remove $x:succ(c)$;
\State add $x:succ(|s_1\cap s_2^\neg|\leq 0)$ and $x:succ(|s_1^\neg\cap s_2|\leq 0)$; return;
\EndIf
\If{$c$ is $l>k$}
\State $c:=k +1\leq l$; return;
\EndIf
\If{$c$ is $k<l$}
\State $c:=k +1\leq l$; return;
\EndIf
\If{$c$ is $l\geq k$}
\State $c:=k\leq l$; return;
\EndIf
\If{$c$ is $l=k$ and a cardinality constraint}
\State remove $x:succ(c)$;
\State add $x:succ(l\leq k)$ and $x:succ(k\leq l)$; return;
\EndIf
\EndFor\\
\ForEach{assertion $x:C$ or $(x,y):s$}
\State $C:=NNF(C)$ or $s:=NNF(s)$;
\EndFor
\end{algorithmic}
\end{algorithm}
The first part of the transformation runs in worst case in polynomial time: If any of the first four conditions holds, we only replace $c$ which runs in constant time.  The complexity of a removing function depends on the implementation: If we have direct access to the elements in the ABox the remove function has a constant (runtime) complexity. If we have some kind of sorting then the (runtime) complexity is logarithm. In worst case if we the ABox is stored as a simple list, then the (runtime) complexity is linear. Hence in worse cast the first part runs in polynomial time. The second part always runs in polynomial time because each transformation into $NNF$ runs in linear time. Hence our desired form of the ABox can be obtained in a polynomial time.\\
The idea of a Tableau-algorithm is rather simple: We apply rules in a arbitrary order whenever they are applicable. However often some caution has to be made. In general we do not want to apply rules which \textit{does not help} to satisfies assertion and hence results in a not necessary long runtime. For example we do not want to repeat any rule applications order, which can be applied infinity times. In \cite{1} the considered DL is $\mathcal{ALCQ}$ which allows qualified number restrictions. The algorithm uses a rule for replacing variables but to prevent endless loops of rule application, which can occur due to the replication, a safeness condition is added. In \cite{2} and \cite{6} the considered DL allows inverse roles which is handled with blocking techniques. A similar blocking technique is used in \cite{Ba} also to prevent non-termination due to considered cyclic TBoxes. The DL $\mathcal{ALCSCC}$ is a very expressive concept language and hence there are some difficulty to handle for the Tableau-algorithm. Hence we also restrict the algorithm on ABoxes $S$ in which each variable does not have a successor yet.
\subsection{Blocking}
In this section we explain the blocking technique for our algorithm.\\
For blocking we introduce a blocking set $b(S,x)$ which contains set terms we want to be blocked in $S$.
\begin{mydef}[Blocking Set $b(S,x)$ \RM{1}]
The blocking set $b(S,x)$ denotes all set terms such that for a variable $y$ we can not add $(x,y):u$ to $S$ if $u=n_1\cdot|s_1|+\dots+n_j\cdot|s_j|$ and $s_i\cup u\in b(S,x)$, $1\leq i\leq j$. We say $u$ is blocked for $x$ in $S$.
\end{mydef}
Now we have to define which set term needs to be block. Intuitively we want to block any set terms which are capable of violating satisfied assertion. However blocking blindly any introduction of set terms because they might violate satisfied assertion can block us from getting a satisfied ABox. The following example shows this kind of situation:
\begin{ex}[Why we do not want to block blindly]
\begin{align*}
S=\{x:succ(1\leq |A|)\sqcap succ(3\cdot|A|\leq 5\cdot|B|)\sqcap succ(5\cdot|B|\leq 3\cdot|A|)\}
\end{align*}
The only assertion which is violated is $x:succ(1\leq|A|)$. Hence we add a successor in $A$. Because of that $x:succ(3\cdot|A|\leq 5\cdot|B|)$ becomes violated. Hence we add a successor in $B$ to satisfy this assertion. But then the last assertion $x:succ(5\cdot|B|\leq 3\cdot|A|)$ becomes violated. If we had blocked either $A$ or $B$ then we could not have added any assertions which means that $S$ is unsatisfiable. But we can see that $S$ is indeed satisfiable by adding five successors in $A$ and three successors in $B$. 
\end{ex}
Therefore we need detect whether a subset of $S$ consisting of $succ$-assertion of a variable $x$ is satisfiable or not. If not we want to block any set term occurring in any cardinality constraint. For that we proceed as follows:
First we build for a variable subsets of $succ$-assertions, which affect each other, formulate a $QFBAPA$ formula of each subset and then let a $QFBAPA$ solver determine whether the formula and hence the subset is satisfiable. If the solver states that the formula is unsatisfiable then we add any set terms, which occurs semantically in any cardinality term in the subset, to $b(S,x)$.
\begin{mydef}[The blocking set $b(S,x)$ \RM{2} - $QFBAPA$ formula]
Let $\mathcal{A}$ be a set of assertions. If $\mathcal{A}$ is unsatisfiable then
\begin{align*}
&b(S,x)=b(S,x)\cup\\
&\{s_i|k=n_0+n_1\cdot|s_1|+\dots+n_j\cdot|s_j|,\,\forall i:1\leq i\leq j,\, x:succ(k\leq l)\in\mathcal{A}\}\cup\\
&\{s_i|l=n_0+n_1\cdot|s_1|+\dots+n_j\cdot|s_j|,\,\forall i:1\leq i\leq j,\, x:succ(k\leq l)\in\mathcal{A}\}\cup\\
&\{s_i|l=n_0+n_1\cdot|s_1|+\dots+n_j\cdot|s_j|,\,\forall i:1\leq i\leq j,\, x:succ(n\,dvd\, l)\in\mathcal{A}\}
\end{align*}
\end{mydef}
So before the Tableau-algorithm starts, we want to divide all assertions of the form $x:succ(c)$ into sets:
\begin{algorithm}[H] \caption{Dividing assertions into depending sets}
\begin{algorithmic}[l]
\State ABox $S$
\ForEach{assertion $x:succ(c)\in S$}
\State create a new set $\mathcal{A}=\{x:succ(c)\}$
\State remove $x:succ(c)$ from $S$
\ForEach{assertion $x:succ(c)\in \mathcal{A}$}
\State $c$ is either $k\leq l$ or $n\,dvd\,l$
\State $l=n_0+n_1\cdot|l_1|+\dots+n_j\cdot|l_j|$
\ForEach{assertion $x:succ(d)\in S$, $d\in\{p\leq q,n\,dvd\,q\}$}
\If{$\exists i\in\{1,\dots,j\}: l_i$ occurs semantically in $p$ or $q$}
\State remove $x:succ(d)$ from $S$
\State $\mathcal{A}=\mathcal{A}\cup\{x:succ(d)\}$
\EndIf
\EndFor
\EndFor
\EndFor\\
\Return all $\mathcal{A}$
\end{algorithmic}
\end{algorithm}
We then create for each $\mathcal{A}$ a $QFBAPA$ formula as follows
\begin{itemize}
\item drop every $x:succ$
\item replacing each role name $r\in\mathbf{R}$ in the assertion by a variable $X_r$ and each concept name $C\in\mathbf{C}$ by $X_C$
\item connect formulas with $\wedge$
\end{itemize}
Note in case of $r^\neg$ or $\neg C$ we have in the formula $X_r^\neg$ and $X_C^\neg$.\\ 
The $QFBAPA$ formula for Example 1 would be $1\leq |X_A|\wedge 2\cdot|X_A|\leq 3\cdot|X_B|\wedge 3\cdot|X_B|\leq 2\cdot|X_A|$.
\subsection{Safe introduction and merging of variables}
For an assertion $x:succ(k\leq l)$ it is not enough to use the blocking set alone to determine whether it is \textit{safe} to introduce a variable. Intuitively we want to increase $l$ alone. But it can happen that by increasing $l$ we also increase $k$ e.g. $x:succ(|A\cup B|\leq |A|+|B|)$. In such a case we only want to add new assertion regarding a new variable $y$ if $l$ increases faster then $k$. To determine whether a set term $u$ is safe depends on how often it occurs semantically in $k$ and $l$. We call this number $n_k(u)$ and $n_l(u)$ and is calculated as follows:
\begin{algorithm}[H] \caption{Compute $n_k(u)$}
\begin{algorithmic}[l]
\State $n_k(u):=0$
\State $k=n_0+n_1\cdot|s_1|+\dots+n_j\cdot|s_j|$
\State $u=t_1\cap \dots \cap t_o$
\ForEach {$1\leq i\leq j:\, n_i\cdot|s_i|$, $s_i=s^\prime_1\cup \dots\cup s^\prime_p$, $p\in\mathbb{N}$}
\If {$\exists q, 1\leq q\leq p:$ $u=s^\prime_q\cap t^\prime$}
\State $n_k(u):=n_k(u)+n_i$
\EndIf
\EndFor\\
\Return $n_k(u)$
\end{algorithmic}
\end{algorithm}
We then can define formally when a set term $u$ is safe.
\begin{mydef}[Safe - introduction]
Let $x:succ(k\leq l)$ be an assertion in $S$. Let $u=t_1\cap\dots \cap t_j$. If $n_k(u)<n_l(u)$ and $u$ is not blocked by $x$ then $u$ is called \textit{safe regarding $x:succ(k\leq l)$}.
\end{mydef}
We look again on Example 1: First we create the set $\mathcal{A}$, which happens to be $S$ itself because all $succ$-assertion affect each other. A $QFBAPA$ solver would return that $\mathcal{A}$ satisfiable and hence no set terms are added to $b(S,x)$. Adding a successor in $A$ regarding the assertion $x:succ(1\leq|A|)$ is safe because only $|A|$ would increase. Now the $x:succ(2\cdot|A|\leq 3\cdot|B|)$ is violated. The set term $B$ is safe and $|A|$ regarding the assertion. Hence we can only add a successor in $B$. If we do that the last assertion $x:succ(3\cdot|B|\leq 2\cdot|A|)$ becomes violated. In this case $A$ is safe and $B$ not regarding this assertion. If we continue then we eventually end with three successors in $A$ and two successors in $B$.\\
Lastly we also look at $x:succ(|A\cup B|\leq |A|+|B|)$ where by adding a successor in $l:=|A|+|B|$ we also increase $k:=|A\cup B|$. Since $n_k(A)=n_l(A)$ and $n_k(B)=n_l(A)$ both $A$ and $B$ are not safe regarding $x:succ(|A\cup B|\leq |A|+|B|)$. But the set term $A\cap B$ is safe because $n_k(A\cap B)=1$ and $n_l(A\cap B)=2$.\\
After updating $b(S,x)$ accordingly we can start the Tableau-algorithm. There is a chance our Tableau-algorithm can enter a unless loop of adding and merging successors: We consider Example 1 in a situation where we already have two successors in $A$ and one in $B$. This means the first assertion is violated. There is now two possibilities how to procedure: merging the two successors in $A$ and adding a new successor in $B$. If the algorithm choose merging we do not get nearer to a satisfied ABox. The worst case here is that we end in an endless loop of adding and merging successors in $A$. However merging is still a valid rule application. To see this we look at the following satisfiable example:
\begin{ex}[Why we want to merge variables]
\begin{align*}
S=\{x:succ(|A\cup B|\leq 1)\sqcap succ:(1\leq|A|)\sqcap succ(1\leq|B|)\}
\end{align*}
\end{ex}
The only violated assertions are $x:succ(1\leq|A|)$ and $x:succ(1\leq|B|)$. Therefore the Tableau-algorithm tries to fix both assertion by adding a successor in $A$ and in $B$ each. However this will leads to $|A\cup B|=2$. There are also no other option to add a successor in $A\cap B$ directly. Hence we want to merge both successors which gives us the required successor in $A\cap B$.\\
Now the question is when we want to merge. We want to avoid a rule application chain which leads to an ABox which we already once obtained. In Example 1 if we once merged two successors in $A$ we do not want to repeat this step again. We have extend Example 2 with $x:succ(1+|A\cap B|\leq |A\cup B|+|t|)$ to explain how we want to block certain merging.
\begin{ex}[Block merging]
\begin{align*}
&S=\{x:succ(|A\cup B|\leq 1)\sqcap succ(1+|A\cap B|\leq |A\cup B|+|t|)\sqcap\\
&succ(1\leq |A|)\sqcap succ(1\leq|B|)\}
\end{align*}
\end{ex} 
Assume we have the situation like above, where we have merged already two successors to one in $A\cap B$. Now the assertion $x:succ(1+|A\cap B|\leq |A\cup B|+|t|)$ is violated but can be fixed (otherwise $\mathcal{A}:=S$ would be unsatisfiable hence the set terms where in $b(S,x)$ and we could not have introduce any successors in $A$ and $B$). Since $b(S,x)$ is empty the Tableau-algorithm any set term consisting of $A\cup B$ and $t$ are safe regarding $x:succ(1+|A\cap B|\leq |A\cup B|+|t|)$. However we can see that adding a successor in $A\cup B$ would lead to an already known situation where we have to merge two successor in $A\cup B$ together, which leads to a violated $x:succ(1+|A\cap B|\leq |A\cup B|+|t|)$ again. Hence we want to block such merging.
\begin{mydef}[Safe - merging]
Let $m(S,x)$ be a set of set terms. Merging two variables $y_1,y_2$ is safe if $\forall t\in m(S,x): y_1\notin t^{\mathcal{I}(S)_x}$ and $y_2\notin t^{\mathcal{I}(S)_x}$. If two variables $y_1,y_2$ are merged together by an assertion $x:succ(k\leq l)$, $k=n_0+n_1\cdot|s_1|+\dots+n_j|s_j|$, we update $m(S,x)$ as follows:
\begin{algorithm}[H] \caption{Updating $m(S,x)$}
\begin{algorithmic}[l]
\ForEach{$1\leq i\leq j$}
\State $s_i=t_1\cup\dots\cup t_q$
\ForEach{$1\leq p\leq q$}
\If{$y_1\in s_p^{\mathcal{I}(S)_x}$ or $y_2\in s_p^{\mathcal{I}(S)_x}$}
\State $m(S,x):=m(S,x)\cup\{s_p\}$;
\EndIf
\EndFor
\EndFor
\end{algorithmic}
\end{algorithm}
\end{mydef}
\section{Algorithm}
For this algorithm it is important to consider the \textit{signs} of concept names and role names.
\begin{mydef}[Positive and Negative Sign]
Let $(x,y):s$ be an arbitrary assertion with $x,y\in Var(S)$ and $s$ being a set term in $NNF$. A concept name $C$ has a \textit{positive sign} in $s$ if no negation sign appears immediately in front of $C$. It has a \textit{negative sign} otherwise. A role name $r$ has a \textit{positive sign} if no negation sign appears above it. It has a \textit{negative sign} otherwise.
\end{mydef}
All concept names in $\mathbf{C}$ and role names in $\mathbf{R}$ have a positive sign.\\
We also loose a bit the property of a Tableau-algorithm that rules can be applied in any order: In case we add $(x,y):s$ to our ABox $S$ and $s$ is a (always finite) chain of disjunction and conjunction we want to add all assertions of $y$ first before applying any other rules.\\
Finally we can present the Tableau-algorithm to determine the satisfiability of an ABox in $\mathcal{ALCSCC}$.
\begin{mydef}[Tableau]
Let $S$ be a set of assertions in simplified $NNF$.
\begin{enumerate}
\item\label{cap} $\sqcap$-rule: $S$ contains $x:C_1\sqcap C_2$ but not both $x:C_1$ and $x:C_2$\\
$\rightarrow$ $S:=S\cup\{x:C_1, x:C_2\}$
\item\label{cup} $\sqcup$-rule: $S$ contains $x:C_1\sqcup C_2$ but neither $x:C_1$ nor $x:C_2$\\
$\rightarrow$ $S:=S\cup\{x:C_1\}$ or $S:=S\cup\{x:C_2\}$
\item\label{choose}$choose$-rule: $S$ contains
\begin{itemize}
\item $x:succ(k\leq l)$
\item $(x,y):k^\prime$, $k=n\cdot|k^\prime\cup u_1|+m\cdot|k^\prime\cap u_2|+s$, $n,m\in\mathbb{N}_0$, $u_1,u_2$ are set terms and $s$ a cardinality term
\item but neither $(x,y):k$ nor $(x,y):k^\neg$
\end{itemize}
$\rightarrow$ either $S:=S\cup\{(x,y):k\}$ or $S:=S\cup\{(x,y):k^\neg\}$. Then jump to rule \ref{repeat}
\item\label{chooserole}$choose$-$a$-$role$-rule: $S$ contains $(x,y):s$ but for any $r\in\mathbf{R}$: $(x,y):r\notin S$\\
$\rightarrow$ choose $r\in\mathbf{R}$, such that $(x,y):r^\neg\notin S$ and $S:=S\cup\{(x,y):r\}$. Then jump to rule \ref{repeat}
\item\label{dvd}$divide$-rule: $S$ contains 
\begin{itemize}
\item $x:succ(n\,dvd\,l)$, which is violated
\item there is a set term $s=s_1\cap \dots \cap s_i$, $l=n_1\cdot|s_1|+\dots+n_i\cdot|s_i|+\dots+n_j\cdot|s_j|$, such that $s$ is not blocked for $x$ in $S$
\end{itemize}
$\rightarrow$ introduce a new variable $y$ and $S:=S\cup\{(x,y):s\}$. Then jump to rule \ref{repeat}
\item\label{leq}$\leq$-rule: $S$ contains 
\begin{itemize}
\item $x:succ(k\leq l)$, which is violated, $l=n_1\cdot|s_1|+\dots+n_i\cdot|s_i|+\dots+n_j\cdot|s_j|$
\item there is a set term $s:=|s_1\cap \dots \cap s_i|$, which is safe to introduce
\end{itemize}
$\rightarrow$ introduce a new variable $y$ $S:=S\cup\{(x,y):s\}$. Then jump to rule \ref{repeat}
\item\label{exceeded}$merge$-rule: $S$ contains
\begin{itemize}
\item $x:succ(k\leq n)$, which is violated
\item $(x,y_1):s_1$ and $(x,y_2):s_2$, such that $y_1\neq y_2$ and $k=n\cdot|s_1\cup s_2\cup t|+u$, where $u$ is a cardinality term, $t$ a set terms, $n\in\mathbb{N}$
\item $y_1$ and $y_2$ are safe to merge
\end{itemize}
$\rightarrow$ merge $y_1$ and $y_2$ 
\item\label{s}$\leq 0$-rule: $S$ contains 
\begin{itemize}
\item $x:succ(|s_1\cap\dots\cap s_j|\leq 0)$
\item $(x,y):s_1$, $\dots$, $(x,y):s_i$, $1\leq i<j$
\item but not $y:s_{i+1}$, $\dots$, $y:s_j$
\end{itemize}
$\rightarrow$ choose $n\in\{i+1,\dots, j\}$, extend $S:=S\cup\{(x,y):s_n^\neg\}$ and then jump to rule \ref{repeat}
\item\label{repeat} $set.term$-rule (Repeat until inapplicable): In $S$ is $(x,y):s$ and
\begin{enumerate}
\item\label{setterm1} $s=s_1\cap s_2$ but $\{(x,y):s_1,\,(x,y):s_2\}\not\subseteq S$\\
$\rightarrow$ $S:=S\cup \{(x,y):s_1,\,(x,y):s_2\}$ 
\item\label{setterm2} $s=s_1\cup s_2$ and neither $\{(x,y):s_1\}\subseteq S$ nor $S\{(x,y):s_2\}\subset S$\\
$\rightarrow$ either $S:=S\cup \{(x,y):s_1\}$ or $S:=S\cup \{(x,y):s_2\}$ 
\item\label{setterm3} $s=C$ and $y:C\notin S$, where $C$ is an $\mathcal{ALCSCC}$ concepts\\
$\rightarrow$ $S:=S\cup\{y:C\}$
\end{enumerate}
\end{enumerate}
\end{mydef}
We now explain the rules of the Tableau-algorithm and their intention.\\
The first rule decompose the conjunction and the second rule adds non-deterministically the right assertion.\\
The $choose$-rule is important because we need to know of every successor what kind of role successors and in which concepts they are. For an assertion $x:succ(k\leq l$ it is important that $k^{\mathcal{I}(S)_x}$ and $l^{\mathcal{I}(S)_x}$ counts the successors correctly. In the following case the successor $y$ is not counted in $l^{\mathcal{I}(S)_x}:=(|r\cap s|^{\mathcal{I}(S)_x})$ while $x:succ(k\leq l)$ is violated.
\begin{ex}
\begin{align*}
S=\{x:succ(1\leq|r\cap s|), (x,y):r\}
\end{align*}
\end{ex}
There might be an model $\mathcal{I^\prime}$ where $y$ is also a $s$-successor of $x$ and hence $l^{\mathcal{I}(S)_x}<l^{\mathcal{I}^\prime(S)_x}$, which means that the assertion is in $\mathcal{I}^\prime$ satisfied, but in $\mathcal{I}(S)$ not. However the Tableau-algorithm should be able to construct every model of $S$ if $S$ is consistent. Therefore this rule adds non-deterministically either $(x,y):s$ or $(x,y):s^\neg$ which are the only two possibilities. This way we are also able to construct $\mathcal{I^\prime}$.\\
The $choose$-$a$-$role$-rule is necessary because in a ABox we may have assertions, which state that $x$ must have a successor but there are no assertions, which states what kind of successor it is. Hence we have to pick the \textit{right} role name. As example we have
\begin{ex}
\begin{align*}
&\mathbf{R}=\{r,s\}\\
&S=\{x:succ(|r^\neg|\leq 1)\}
\end{align*} 
\end{ex}
It states that $x$ have at least one successor which is not a $r$-successor. Since $\mathbf{R}$ only contains $r$ and $s$ we know that the successors must be an $s$-successor. First we apply rule \ref{leq} to actually add a successor. Therefore $y$ is introduced and $(x,y):r^\neg$ is added to $S$. Now no more rules are applicable except for the $choose$-$a$-$role$-rule. With that rule we can not pick $r$ because $r^\neg$ occurs in the assertion. Therefore we have to pick $s$. Another more simple but not so significant example is
\begin{ex}
\begin{align*}
&\mathbf{R}=\{r,s\}\\
&S=\{x:succ(|A|\geq 1)\}
\end{align*} 
\end{ex}
We know that $x$ must have a successor in $A$ but we still need to assign a role. In this case we can choose between $r$ and $s$.
\\
The $divide$-rule is straightforward: We choose one set term $s=s_1\cap\dots\cap s_i$ such that $l=n_1\cdot|s_1|+\dots+n_i\cdot|s_i|+\dots+n_j\cdot|s_j|$ and introduce a new variable $y$ and add $(x,y):s$ to $S$. For any $x:succ(n\,dvd\,l)$ we know that the chain of this rule application is finite because in worst case we have to introduce $n$ new variables with the same set term.
\\
The main idea of the $\leq$-rule is simple: We want to increase $l$ until the constraint is satisfied. By the condition it has to be safe we know that $l$ increases faster than $k$ and that we do not end in a endless loop of adding and merging variables.\\
For the $merge$- rule we restrict the merging to the left hand side of cardinality constraints $k\leq l$: It can be reasonable for the right hand side if by merging $l$ increases, for example $x:succ(1\leq |r\cap t|)$ with $(x,y_1):r$ and $(x,y_2):t$. However the easiest solution is just to add an $r\cap t$-successor. In case it is important to also restrict the number of $r\cap t$-successor e.g. $x:succ(|r\cap t|<2)$ we can define with the $choose$-rule whether $y_1$ and $y_2$ are also $r\cap t$-successor. And then with the assertion $x:succ(|r\cap t|<2)$ we can merge $y_1$ and $y_2$.\\
The $\leq 0$-rule deal with an assertion with a set constraint $s_1\subseteq s_2$, which is written here as cardinality constraint $|s_1\cap s_2^\neg|\leq 0$. Those cardinality constraint can not be dealt with the other rules. In case the left side has at least three set term  e.g. $|s_1\cap s_2\cap s_3|$ we have can have multiple possible solutions e.g. $(x,y):s_1\cap s_2\cap s_3^\neg$, $(x,y):s_1\cap s_2^\neg\cap s_3$ and $(x,y):s_1\cap s_2^\neg\cap s_3^\neg$. Hence we let the algorithm choose and backtrack if needed.\\
The $set.term$-rules are applied immediately after a new assertions $(x,y):s$ is added to $S$. The reason for that is, that we want to add all needed assertions for $y$ and hence update all $k^{\mathcal{I}(S)_x}$ correctly. We know that the number of this application is finite because an ABox is finite and hence the number of concept names and role names occurring in this ABox is also finite. Since the constraints are in $NNF$ set terms can never be infinite and hence this rule applies only a finite times.
\section{Correctness}
For the correctness proof of the Tableau-algorithm we have to show that
\begin{itemize}
\item For every input the Tableau-algorithm terminates
\item If no more rules are applicable on a clash-free ABox $S$ then $S$ is satisfiable
\item If $S$ is satisfiable then the Tableau-algorithm terminates without a clash
\end{itemize}
First we prove that the tableau algorithm terminates. 
\begin{mypro}
Let $C$ be a concept in simplified $CNNF$. Then there is no infinite chain of applications of any tableau rules issuing from $\{x:C\}$. 
\end{mypro}
\begin{mydef}[Derived Set]
A \textit{derived set} is an ABox $S^\prime$ where rule \ref{repeat} is not applicable.
\end{mydef}
In order words a derived set is an ABox on which we applied a rule completely e.g. every time we add a new assertion $(x,y):s$ we add all assertion concluded by it to $S$ (rule \ref{repeat}) first.\\
To prove this we map any derived set $S$ to an element $\Psi(S)$ from a set $Q$. We then show that the elements in $Q$ can be ordered by a well-founded relation $\prec$. A well-founded relation says that there is no infinite decreasing chain. If we can show that by obtaining a derived set $S^\prime$ from another set $S$ we have $\Psi(S^\prime)\prec\Psi(S)$ then the algorithm terminates.\\
The elements in $Q$ are finite multisets of septuples and the elements of the septuples are either integers or mutlisets of integers. For two septuples $q=(q_1,\dots,q_7)$ and $q^\prime=(q^\prime_1,\dots,q^\prime_7)$ it holds $q\prec q^\prime$ if for the first $i,\, 1\leq i\leq 7$, for which $q_i$ and $q_i^\prime$ differs it holds that $q_i\prec q_i^\prime$ (also called lexicographical ordering). For two mutlisets of integers $q_i$ and $q_i^\prime$ it holds $q_i^\prime\prec q_i$ if $q_i^\prime$ can be obtained from $q_i$ by replacing an integer $c$ in $q_i^\prime$ by a finite number of integers which are all smaller than $c$. The relation $\prec$ for those multisets is well-founded because we work with integers. That means from a multiset $\{0,\,\dots\,,0\}$ the smallest multiset which can be obtain is $\{\}$ by removing all $0$s.\\
For a concept $C$ its size $size(C)$ is inductively defined as
\begin{itemize}
\item $0$, if $C$ is $\perp$
\item $1$, if $C$ is a concept name of $\mathbf{C}$
\item $size(\neg C)= 1+size(C)$
\item $size(succ(c))= 1 + \sum_{C\text{ in c}} size(C)$
\item $size(C\sqcap D)=size(C\sqcup D)=size(C)+size(D)$
\end{itemize}
The asymmetrical difference of two numbers $n,m$ is denoted by 
\begin{equation*}
n\unlhd m \begin{cases}
n-m& \text{if } n> m\\
0 & \text{if } n\leq m
\end{cases}
\end{equation*}
The septuples in $Q$ are defined as follows
\begin{mydef}
Let $S$ be an ABox. The multiset $\Psi(S)$ consist of septuples $\psi_S(x)$ for each variable $x$. The component of the septuples are structured as follows
\begin{itemize}
\item the first component is a non-negative integer $max\{size(C)\mid x:C\in S\}$
\item the second component is a multiset of integers containing for each $x:C\sqcap D$, on which the $\sqcap$-rule is applicable, the non-negative integer $size(C\sqcap D)$ (respectively for $C\sqcup D$)
\item the third component is the number of $x$'s successors on which rule \ref{chooserole} is applicable
\item the fourth component is a multiset of integers containing for each $x:succ(k\leq n)\in S$ the number of all successors $y$ of $x$ on which rule \ref{choose} is applicable
\item the fifth component is a multiset which denotes for every $x:succ(k\leq l)$ and $x:succ(n\,dvd\,l)$ the integer $k^{\mathcal{I}(S)_x}\unlhd l^{\mathcal{I}(S)_x}$ and $n\unlhd l^{\mathcal{I}(S)_x}$ respectively
\item the sixth component denotes the number of all successors of $x$.
\item the seventh component is a multiset which denotes for each $x:succ(k\leq 0)$ the number of successors on which the rule \ref{leq} is applicable
\end{itemize}
\end{mydef}
\begin{mylem}
The following properties hold
\begin{enumerate}
\item For any concept $C$ we have $size(C)\geq size(NNF(\neg C))$
 \item Any variable $y$ in a derived set $S$ has at most one predecessor $x$ in $S$
\item If $(x,y):r\in S$ for a $r\in\mathbf{R}$ (and $y$ is a introduced variable) then 
\begin{align*}
max\{size(C)\mid x:C\in S\}>max\{size(D)\mid y:D \in S\}
\end{align*}
\end{enumerate}
\end{mylem}
\begin{proof}$ $\\
\vspace*{-5mm}
\begin{enumerate}
\item By induction over the number of applications to compute the negation normal form we have $size(C)=size(NNF(\neg C))$. Because $\neg succ(0\leq k)$ can be replace by $\perp$ which is $smaller$, we have $size(C)\geq size(NNF(\neg C))$. This can be done because $\neg succ(0\leq k)= succ(k<0)$ which is impossible to satisfy and therefore $\neg succ(0\leq k)=\perp$.
\item If $y$ is a newly introduced variable, then it can only be introduced by exactly one variable $x$ which is $y$'s only predecessor. If two variables are merged together by rule \ref{exceeded} then both variables must have the same predecessor $x$ by the condition of that rule.
\item By the second fact we know that $x$ is the only predecessor of $y$. When $y$ is introduced by applying \ref{leq} on a assertion $x:succ(k\leq l)$ then we have $y:C$ for every concept $C$ occurring in $l$ (for $\neg C$ we have $y:\neg C$). We know that $size(succ(k\leq l))$ is greater then $size(C)$ therefore Lemma 1.3 holds. A new assertion $y:D$ can occur either because rule \ref{cap} or \ref{cup} are applicable on $y:C$ with $C=D\sqcap D^\prime$ or $C=D\sqcup D^\prime$, which neither raise $max\{size(D)\mid y:D \in S\}$, or because rule \ref{choose} is applicable but that also does not raise $max\{size(D)\mid y:D \in S\}$: If rule \ref{choose} is applicable on $x:succ(k\leq l)$ then for every added assertion $y:D$ the concept $D$ must occur in $k$ and therefore $size(succ(k\leq l))>size(D)$. If $y$ gets merged together with another variable $z$, then $y$ and $z$ must have the same predecessor which means that all concept sizes regarding $z$ are also smaller then $max\{size(C)\mid x:C\in S\}$. 
\end{enumerate}
\end{proof}
From the next Lemma we can conclude that the Tableau-algorithm terminates.
\begin{mylem}
If $S^\prime$ is a derived set obtained from the derived set $S$, then $\Psi(S^\prime)\prec\Psi(S)$
\end{mylem}
\begin{proof}
The following proof is sectioned by the definition of obtaining a derived set.
\begin{enumerate}
\item $S^\prime$ is obtained by the application of rule \ref{cap} on $x:C\sqcap D$:\\
The first component remains the same because $size(C)<size(C\sqcap D)$ and $size(D)<size(C\sqcap D)$. The second component decreases because rule \ref{cap} can not be applied on $x:C\sqcap D$ any more meaning that the corresponding entry in the multiset is removed. If $C$ (or $D$) happens to be a disjunction ($C^\prime\sqcup D^\prime$) or a conjunction ($C^\prime\sqcap D^\prime$) then the second component also becomes smaller because $size(C^\prime)$ and $size(D^\prime)$ are always smaller than the disjunction or conjunction of them and therefore also smaller than $size(C\sqcap D)$. Hence the entry for $size(C\sqcap D)$ can be replace by the smaller $size(C^\prime\sqcup D^\prime)$ or $size(C^\prime\sqcap D^\prime)$.\\
Consider now a tuple $\psi_S(y)$ such that $x\neq y$. $\psi_S(y)$ can only be affected if $x$ is a successor of $y$. The first and second component of $\psi_S(y)$ remain unaffected because both are independent from $x$. The third and fourth component of can never in creases because we do not add any new successors. If at all the components can decreases because it may happen that by adding assertions regarding $x$ rule \ref{choose} (or rule \ref{chooserole}) can not be applied any more on some assertion $y:succ(k\leq l)$. The same goes for the fifth component: If there is an assertion $y:succ(k\leq l)$ and by adding $x:C$ and $x:D$ to $S$ neither $k^{\mathcal{I}(S^\prime)_y}$ nor $l^\mathcal{I}(S)_y$ change because by the definition of $\mathcal{I}(S)$ we have $x\in (C\sqcap D)^{\mathcal{I}(S)_y}=C^{\mathcal{I}(S)_y}\sqcap D^{\mathcal{I}(S)_y}\subseteq C^{\mathcal{I}(S)_y}$ and $\subseteq D^{\mathcal{I}(S)_y}$. This means that $x$ is not added to any further extension in $\mathcal{I}(S^\prime)$ and hence $k^{\mathcal{I}(S^\prime)_y}$ nor $l^{\mathcal{I}(S)_y}$ remain the same. The sixth component also do not change: From the beginning we have $x:C\sqcap D$, which means that if rule \ref{leq} is not applicable then it stays inapplicable after $x:C$ or $y:D$ is added. We can conclude that the tuple $\psi_S(y)$ remains in total unchanged or decreases.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$ and, if needed, $\psi_S(y)$ with a smaller tuple $\psi_{S^\prime}(y)$. 
\item $S^\prime$ is obtained by the application of rule \ref{cup} on $x:C\sqcup D$:\\
similar to above
\item $S^\prime$ is obtained by the application of rule \ref{choose} on $x:succ(k\leq l)$ for a successor $y$ and of rule \ref{repeat}:\\
The first and second component of $\psi_S(x)$ do not change because this step only adds assertion regarding $y$. The third component can not increase: If rule \ref{chooserole} is applicable then there is a change that by adding the new assertion $(x,y):k$ we also add $(x,y):r,r\in\mathbf{R}$ (by rule \ref{repeat}), which leads to the fact that rule \ref{chooserole} is not applicable any more and hence the tuple becomes smaller. The fourth component becomes smaller because rule \ref{choose} can not be applied any more on $y$ and hence the corresponding number in the multiset decreases which lead to a smaller tuple $\psi_{S^\prime}(x)$.\\
We consider now a tuple $\psi_S(z)$ such that $y\neq z$ and $x\neq z$. The tuple $\psi_S(z)$ can only be affected if $z$ is the predecessor of $y$. However by Lemma 1.2 a variable can only have one predecessor and hence $z$ must be $x$.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$. 
\item $S^\prime$ is obtained by the application of rule \ref{chooserole} on a successor $y$ and of rule \ref{repeat}:\\
The first two component remains unchanged. The third component always decreases because the number of $x$'s successor on which rule \ref{chooserole} is applicable decreases.\\
We consider now a tuple $\psi_S(z)$ such that $y\neq z$ and $x\neq z$. The tuple $\psi_S(z)$ can only be affected if $z$ is the predecessor of $y$. However by Lemma 1.2 a variable can only have one predecessor and hence $z$ must be $x$.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$. 
\item $S^\prime$ is obtained by the application of rule \ref{dvd} on a assertion $x:succ(n\,dvd\,l)$ and of rule \ref{repeat}:\\
The first two components again remains unchanged. \textcolor{red}{lol}
\item $S^\prime$ is obtained by the application of rule \ref{exceeded} on an assertion $x:succ(k\leq l)$:\\
The first two components remains unchanged. The third and fourth component can only decrease because we have one less successor. Furthermore if rule \ref{choose} (or \ref{chooserole} is applicable on at least one of the two variables then by merging we can gain a new variable, on which the rule is inapplicable. Therefore those four component can not increase. The fifth component also can not increase: Since we can apply rule \ref{exceeded} on $x:succ(k\leq l)$ we know that this assertion is violated, hence $k^{\mathcal{I}(S)_x}>l^{\mathcal{I}(S)_x}$. By applying this rule \textcolor{red}{help}....
\end{enumerate}
\end{proof}
\iffalse
\begin{mylem}
If the Tableau-algorithm terminates without a clash then $S$ is satisfiable
\end{mylem}
\begin{proof}$ $\\
Again the proof is sectioned by the obtained derived sets.\\
Let $\mathcal{I}(S^\prime)$ be the induced interpretation of the ABox $S^\prime$ created by the Tableau-algorithm from $S$. We show that $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.\\
We start with the simple assertions $x:C$ and $(x,y):r$ for $C\in\mathbf{C}$ and $r\in\mathbf{R}$ (induction base): By the definition of induced interpretation we assign $\pi_{\mathcal{I}(S^\prime)}(x):=x^{\mathcal{I}(S^\prime)}\in C^{\mathcal{I}(S^\prime)}$. Also by the definition of induced interpretation for every $(x,y):r\in S^\prime$ we have $(\pi_{\mathcal{I}(S^\prime)}(x),\pi_{\mathcal{I}(S^\prime)}(y)):=(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})\in r^{\mathcal{I}(S^\prime)}$.\\
Let $S$ be an ABox and $\pi_{\mathcal{I}(S)}$ be an assignment which satisfies $S$ (induction hypothesis).\par
\begin{enumerate}
\item If we can apply rule \ref{cap} and obtain $S^\prime$ then there must be an assignment $x:C_1\sqcap C_2\in S$. By the definition of induced interpretation and by the hypothesis we already have $\pi_{\mathcal{I}(S^\prime)}(x)\in C_1^{\mathcal{I}(S^\prime)}$ and $\pi_{\mathcal{I}(S^\prime)}(x)\in C_2^{\mathcal{I}(S^\prime)}$. By adding $x:C_1$ and $x:C_2$ we do not change $\mathcal{I}(S)$. Hence $\mathcal{I}(S^\prime):=\mathcal{I}(S)$ and $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{cup} and obtain $S^\prime$ then there must be an assignment $x:C_1\sqcup C_2\in S$. Like above by the definition of the induced interpretation we have $\pi_{\mathcal{I}(S^\prime)}(x):=x^{\mathcal{I}(S^\prime)}$. We also know that $x^{\mathcal{I}(S^\prime)}$ is in $C_1^{\mathcal{I}(S^\prime)}\cup C_2^{\mathcal{I}(S^\prime)}$. By adding either $x:C_1$ or $x:C_2$ we do not change $\mathcal{I}(S)$. Hence $\mathcal{I}(S^\prime):=\mathcal{I}(S)$ and $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{choose} and obtain $S^\prime$ then we have an assertion $x:succ(k\leq l)$ and a successor $y$ such that $(x,y):k^\prime\in S$, $k^\prime$ occurs in $k$. We then choose between $(x,y):s$ and $(x,y):s^\neg$ for all $|s|$ in $k$ then apply rule \ref{repeat} until this rule is inapplicable. That means at the end we might add several assertions of the form $x:C$ and $(x,y):r$. In case we add $x:C$ we also add $x^{\mathcal{I}(S^\prime)}$ to $C^{\mathcal{I}(S^\prime)}$. Therefore in this case $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$. In case we add $(x,y):r$ we also add $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ to $r^{\mathcal{I}(S^\prime)}$. Hence $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{chooserole} and obtain $S^\prime$ then we have an assertion $(x,y):k$ but for every role name $r$ we do not have $(x,y):r\in S$, where $r$ has a positive sign in this assertion. After adding $(x,y):r$, $r\in\mathbf{R}$, to $S^\prime$ the element $(x^{\mathcal{I}(S)},y^{\mathcal{I}(S)})$ is also added to $r^{\mathcal{I}(S^\prime)}$. Hence $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{leq} and obtain $S^\prime$ then we have an assertion $x:succ(c)$ such that it is violated regarding $x$.\\
We introduce $y$ and add $(x,y):l$ to $S$ and then apply rule \ref{repeat} until this rule is inapplicable. When we introduce $y$ we also add a new element $y^{\mathcal{I}(S^\prime)}$ to $\mathcal{I}(S^\prime)$. For each $y:C$ we add $y^{\mathcal{I}(S^\prime)}$ to $C^{\mathcal{I}(S^\prime)}$ and for each $(x,y):r$, $r\in\mathbf{R}$, we add $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ to $r^{\mathcal{I}(S^\prime)}$. Therefore let $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}\cup \{y\mapsto y^{\mathcal{I}(S^\prime)}\}$.
\item If we can apply rule \ref{leq} and obtain $S^\prime$ then we have an assertion $x:succ(k<l)$ or $x:succ(k\leq l)$ such that it is violated regarding $x$. We also have two successors $y_1$ and $y_2$ for which $(x,y):s$ and $(x,y):s$ are in $S$.\\
If we merge both together to $y$ we also have to merge $y_1^{\mathcal{I}(S)}$ and $y_2^{\mathcal{I}(S)}$ to one element $y^{\mathcal{I}(S^\prime)}$. For each $y_i:C\in S$, $i\in\{1,2\}$ we have $y_i^{\mathcal{I}(S)}\in C^{\mathcal{I}(S)}$ and for each $(x,y_i):r$, $r\in\mathbf{R}$ we have $(x^{\mathcal{I}_S},y_i^{\mathcal{I}(S)})\in r^{\mathcal{I}(S)}$ due to the hypothesis. That means that by merging both elements the element $y^{\mathcal{I}(S^\prime)}$ must be in $C^{\mathcal{I}(S^\prime)}$ for every $y_i^{\mathcal{I}(S)}\in C^{\mathcal{I}(S)}$ and the element $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ must be in $r^{\mathcal{I}(S^\prime)}$ for every $(x^{\mathcal{I}(S)},y_i^{\mathcal{I}(S)})\in r^{\mathcal{I}(S)}$. Therefore let $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}\backslash\{y_1\mapsto y_1^{\mathcal{I}(S)}, y_2\mapsto y_2^{\mathcal{I}(S)}\}\cup\{y\mapsto y^{\mathcal{I}(S)}\}$ which satisfies $S^\prime$.
\item If we can apply rule \ref{s} and obtain $S^\prime$ then we have an assertion $x:succ(c_1\subseteq c_2)$ and a successor $y$ such that $(x,y):c_1\in S$ but $(x,y):c_2\notin S$. By adding $(x,y):c_2$ to $S$ we have also to add $y:C$ for every concept $C$ in $c_2$ and $(x,y):r$ for every role name $r$ in $c_2$. That means that $x^{\mathcal{I}(S)}$ is added to every $C^{\mathcal{I}(S)}$ and that $(x^{\mathcal{I}(S)},x^{\mathcal{I}(S)})$ is added to every $r^{\mathcal{I}(S)}$. Therefore the assignment $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\end{enumerate}
\end{proof}
\begin{mylem}
If $S$ is satisfiable then the Tableau-algorithm terminates without a clash.
\end{mylem}
\begin{proof}
\end{proof}
\fi
\normalem
\bibliographystyle{abbrv}
\bibliography{ref}
\end{document}
