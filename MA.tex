\documentclass[a4paper,11pt]{scrartcl}
\usepackage[english]{babel}  % falls der Artikel auf Deutsch verfasst ist
% Verwenden Sie nur EINE der beiden folgenden Zeilen, je nachdem, ob Ihr
% Betriebssystem LATIN1 (=ISO-8859-1) oder UTF8 als Zeichenkodierung
% verwendet. Ob Sie die richtige verwenden, merken Sie daran, dass
% die Umlaute richtig im Dokument dargestellt werden.
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{dsfont}
\usepackage{float}
\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {\itshape}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
\theoremstyle{definition}
\newtheorem{mydef}{Definition}
\newtheorem{mylem}{Lemma}
\newtheorem{mythe}{Theorem}
\newtheorem{mycol}{Corollary}
\newtheorem{mypro}{Proposition}
\newtheorem{ex}{Example}
\usepackage{color}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes,arrows}
\usepackage{verbatim}
\usetikzlibrary{positioning}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{pgfplots}
\pgfplotsset{compat=1.8}
\usetikzlibrary{patterns}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\usepackage{ulem}
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}
\usepackage{url}
\makeatletter
\newcommand{\oset}[3][0ex]{%
  \mathrel{\mathop{#3}\limits^{
    \vbox to#1{\kern-2\ex@
    \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother
\pgfplotsset{
    standard/.style={
        axis x line=middle,
        axis y line=middle,
        enlarge x limits=0.1,
        enlarge y limits=0.15,
        every axis x label/.style={at={(current axis.right of origin)},anchor= north west},
        every axis y label/.style={at={(current axis.above origin)},anchor= east}
    }
}
\begin{document}
\tableofcontents
\newpage
\section{Introduction}
Traditional data bases where data are stored solely without any connection towards to themselves like many people would imagine are often not enough any more. The reason is that the data are stored without any semantics. However storing data with semantics can provide additional information. For example we have some data about two objects \textit{"Anna"} and \textit{"Beth"}. In a traditional data base if not explicitly stated, both data are not related to each other. Nethertheless Anna and Beth can have a relation, which also depends on who or what both are. For example both can be human and Anna is a teacher and Beth is a student. Both are in the same class. By adding solely those information in a traditional data base the information that Anna must teaches Beth is not given. One way to apply semantics to data objects is to use \textit{ontologies}. In biological and (bio)medical researches data bases are often based on ontologies \cite{bio}. Ontologies (in the computer science field) can be viewed as formal representation of a certain domain of interest. In data base they are collection of relation between the entities in the data base and are formulated as a fragment of first-order logic (FOL). These fragments of FOL are represented as \textit{Description Logic (DL)}, which is a family of knowledge representation system. DL are mainly built of concepts, which correspond to unary relations in FOL and is often represented by a capital letter, and relation between the concepts, which correspond to binary relations in FOL and is often represented by a lowercase letter. For more complex (compound) concepts operators like $\sqcap$, $\sqcup$,$\sqsubseteq$, $\exists$ and $\forall$, depending on the DL, are used. For example the statement "All Men and Women are Human" is formalize in FOL as $\forall x.Men(x)\vee Women(x)\rightarrow Human(x)$ and in DL as an \textit{axiom} $Men\,\sqcup\, Women\sqsubseteq Human$, where $Men$,$Women$ and $Human$ are concept names. The statement "All Humans, who have children, are parents" can be formalized in FOL as $\forall x \exists y. Human(x)\wedge hasChildren(x,y)\rightarrow Parent(x)$ and in DL as $Human\sqcap \exists hasChildren.\top \sqsubseteq Parent$, where $Human$ and $Parents$ are concept names and $hasChildren$ is a role name. Restriction with the operators $\exists$ and $\forall$ are called \textit{quantified} restrictions. The second statement can also be formalized with a \textit{qualified} restriction: $Human\sqcap \geq 1 hasChildren.\top\sqsubseteq Parent$. Each quantified restriction can be transformed into a qualified restriction.\\
One big research field in DL is the determination of satisfiability of an \textit{knowledge base}, which is formulated in DL. A knowledge base normaly consists of a \textit{TBox}, which contains the axioms (rules), and of an \textit{ABox} which contains assertions of certain elements (objects). This DL allows conjunctions ($\sqcap$), disjunctions ($\sqcup$), negation $\neg C$ and qualifying number restriction ($\leq\,n\,r\, C$ and $\geq \, n\, r\, C$), where $n$ is a number, $r$ a role name, and $C$ a concept name. In \cite{1} a \textit{Tableau}-algorithm is presented for checking satisfiability for an ABox in the DL $\mathcal{ALCQ}$. A Tableau-algorithm applies \textit{completion rules} to a given \textit{set}(ABox) to decompose complex concepts and try satisfiying violated \textit{statements}(assertions). If the set concludes something unsatisfiable (clash) then the whole set is unsatisfiable. If no more rules are applicable and the set is not unsatisfiable, then it is otherwise. The satisfiability (of concepts) is stated in \cite{1} as PSPACE-hard problem (without TBox, with TBox it is EXPTime-hard \cite{4}. In \cite{pspace} a optimized Tableau-algorithm is presented which results in a PSPACE-problem. The optimization is that instead of keeping $n$ successors to satisfy a restriction $\geq\,n\,r.C$ like in \cite{1}, the algorithm saves the number of existing successors and by comparing the numbers detects possible clashes. This DL is more expressive than $\mathcal{ALCQ}$ because every qualified restriction $\leq\,n\,r.C$ and $\geq \, n\, r.C$ can be written in $\mathcal{ALCSCC}$ as $succ(|r.C|\leq 1)$ and $succ(|r.C|\geq 1)$. \\
The expressive DL $\mathcal{ALCSCC}$ extends $\mathcal{ALCQ}$ with \textit{set constraint} and \textit{cardinality constrant}, which lays under the logic of \textit{QFBAPA} (quantifier-free fragment of Boolean Algebra with Presburger Arithmetic). As the name says we do not have quantifier. Instead we use set expression (Boolean Algebra part) and numerical constraint (Presburger Arithmetic) which is combined together with cardinality functions. For example $Human\sqcap \geq 1\,hasChildren.\top\sqsubseteq Parent$ is written in $\mathcal{ALCSCC}$ as $Human\sqcap succ(|hasChildren|\geq 1)\sqsubseteq Parent$. In \cite{4} a solution for the satisfiability problem (without TBox) is presented which has the complexity PSpace: For an ABox we guess the value (true or false) of the top-level variables which can already lead to a \textit{false}-result. If not then the constraint is formulated into a $QFBAPA$ formula, for which an algorithm determine by guessing a number $N$ of Venn-region to be non-empty whether the formula is satisfied or not.\\
In this work we give another solution for the satisfiability problem with a Tableau-algorithm. As in previous work for other DLs we define completion rules which can be applied onto assertions in the ABox to determine whether $\perp$ can be concluded from it which states its unsatisfiability. If we can not apply any rules any more and we can not conclude $\perp$, then the ABox is satisfiable. The main difficulty is that unlike $\mathcal{ALCQ}$, where the bond of number of successor is fixed, in $\mathcal{ALCSCC}$ we can compare two cardinalities, which can vary during the algorithm. Hence we need an approach for counting successors and with it calculating the \textit{correct} cardinality, which is necessary to detect satisfied and violated constraint. For this we introduce \textit{induced interpretation} which can determine the cardinalities after each rule application. Further more to deal with the numerical arithmetic of $\mathcal{ALCSCC}$ we use a $QFBAPA$ solver. We transform a subset of the ABox into a $QFBAPA$ formula and then let a solver determine whether the formula is satisfiable or not. If not we end with a clash. If it returns a solution, then we add variables according to it to our ABox.
\section{Preliminaries}
Before we define the DL $\mathcal{ALCSCC}$ we have to explain first how the language $QFBAPA$ looks like.
\begin{mydef}[$QFBAPA$]
Let $T$ be a set of symbols
\begin{itemize}
\item set terms over $T$ are:
\begin{itemize}
\item empty set $\emptyset$ and universal set $
\mathcal{U}$
\item every set symbol in $T$
\item if $s,t$ are set terms then also $s\cap t$, $s\cup t$ and $s^{\neg}$
\end{itemize}
\item set constraints over $T$ are
\begin{itemize}
\item $s\subseteq t$ and $s\not\subseteq t$
\item $s=t$ and $s\neq t$
\end{itemize}
where $s,t$ are set terms
\item cardinality terms over $T$ are:
\begin{itemize}
\item every number $n\in \mathbb{N}$
\item $|s|$ if $s$ is a set term
\item if $k,l$ are cardinality terms then also $k+l$ and $n\cdot k$, $n\in \mathbb{N}$
\end{itemize}
\item cardinality constraints over $T$ are:
\begin{itemize}
\item $k=l$ and $k\neq l$
\item $k<l$ and $k\geq l$
\item $k\leq l$ and $k>l$
\item $n$ $dvd$ $k$ and $n$ $\neg dvd$ $k$
\end{itemize}
where $k,l$ are cardinality terms and $n\in\mathbb{N}$
\end{itemize}
A $QFBABA$ formula $\phi$ is a disjunction ($\vee$) and conjunction ($\wedge$) of (also possible negated) cardinality constraints, where every set symbol is represented as a set variable.
\end{mydef}
Since $s\subseteq t$ can be expressed as the cardinality constraint $|s\cap t^\neg|\leq 0$ we will not consider any set constraints further in this work. In case we want to express $x:succ(s=t)$, with $s,t$ being set terms, we write instead $x:succ(|s\cap t^\neg|\leq 0)\sqcap succ(|s^\neg\cap t|\leq 0)$. Furthermore instead of $l\geq k$ we write $k\leq l$, instead of $k<l$ we write $k+1\leq l$ and instead of $k=l$ we write $k\leq l$ and $l\leq k$. Hence for an assertion $x:succ(c)$ the cardinality constraint $c$ is either of the form $k\leq l$ or $n\,dvd\,l$.\\
The semantic of $QFBAPA$ is define as follows:
\begin{mydef}[Interpretation of $QFBAPA$]
Let $\Delta^\mathcal{I}$ be a set and $\sigma$ a mapping which maps
\begin{itemize}
\item every symbol $a$ in $T$ to $\sigma(a)$
\item $\emptyset$ to $\sigma(\emptyset)$
\item $\mathcal{U}$ to $\sigma(\mathcal{U})\subseteq \Delta^\mathcal{I}$
\item $\sigma(s\cap t):= \sigma(s)\cap \sigma(t)$, $\sigma(s\cup t):= \sigma(s)\cup \sigma(t)$
\item $\sigma(s^\neg):=\sigma(\mathcal{U})\backslash \sigma(s)$
\item $\sigma(|s|):=|\sigma(s)|$
\item $\sigma(k+l):=\sigma(k)+\sigma(l)$, $\sigma(n\cdot k):= n\cdot \sigma(k)$
\end{itemize}
The mappings satisfies for the cardinality terms $k,l$
\begin{itemize}
\item $k\leq l$ iff $\sigma(k)\leq \sigma(l)$
\item $n\,dvd\,l$ iff $\exists m\in\mathbb{N}:n\cdot m = \sigma(l)$
\end{itemize}
\end{mydef}
The mapping $\sigma$ is a solution of a $QFBAPA$ formula if it satisfies all cardinality constraints.\\
Let $\mathbf{C}$ be a set of concept names and $\mathbf{R}$ a set of role names, such that $\mathbf{C}$ and $\mathbf{R}$ are disjoint.
\begin{mydef}[$\mathcal{ALCSCC}$]
$\mathcal{ALCSCC}$ concepts are defined inductively:
\begin{itemize}
\item all concept names
\item if $C,D$ are concepts then:
\begin{itemize}
\item $\neg C$
\item $C\sqcup D$
\item $C\sqcap D$
\end{itemize}
\item $succ(c)$ if $c$ is a cardinality constraint over $\mathcal{ALCSCC}$ concepts and role names
\end{itemize}
\end{mydef}
An ABox $\mathcal{A}$ in $\mathcal{ALCSCC}$ is a finite set of assertions of the form $x:C$ and $(x,y):r$, where $C$ is a $\mathcal{ALCSCC}$ concept, $r\in\mathbf{R}$ and $x,y$ are variables. The set $Var(\mathcal{A})$ is the set of variables occurring in $\mathcal{A}$. 
\begin{mydef}[Interpretation]
An \textit{interpretation} $\mathcal{I}=(\Delta^\mathcal{I},\cdot^\mathcal{I})$ over an ABox $\mathcal{A}$ in $\mathcal{ALCSCC}$ consists of a non-empty set $\Delta^\mathcal{I}$ and a mapping $\cdot^\mathcal{I}$ which maps:
\begin{itemize}
\item each variable $x\in Var(\mathcal{A})$ to $x^\mathcal{I}\in \Delta^\mathcal{I}$
\item every concept names $A\in\mathbf{C}$ to $A^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item every role name $r\in\mathbf{R}$ to $r^\mathcal{I}\subseteq\Delta^\mathcal{I}\times\Delta^\mathcal{I}$, such that every element in $\Delta^\mathcal{I}$ has a finite number of successors.
\end{itemize}
The set $r^\mathcal{I}(x)$ contains all elements $y$ such that $(x,y)\in r^\mathcal{I}$ e.g. it contains all $r$-successors of $x$.\\
For compound concepts the mapping $\cdot^\mathcal{I}$ is extended inductively as follows
\begin{itemize}
\item $\top^\mathcal{I}=\Delta^\mathcal{I}$ and $\perp^\mathcal{I}=\emptyset^\mathcal{I}$
\item $(C\sqcap D)^\mathcal{I}:=C^\mathcal{I}\cap D^\mathcal{I}$, $(C\sqcup D)^\mathcal{I}:=C^\mathcal{I}\cup D^\mathcal{I}$
\item $(\neg C)^\mathcal{I}:=\Delta^\mathcal{I}\backslash C^\mathcal{I}$
\item $succ(c)^\mathcal{I}=\{x\in \Delta^\mathcal{I}|$the mapping $\cdot^{\mathcal{I}_x}$ satisfies $c\}$
\end{itemize}
The mapping $\cdot^{\mathcal{I}_x}$ maps $\emptyset$ to $\emptyset^\mathcal{I}$, $\mathcal{U}$ to $\mathcal{U}^{\mathcal{I}_x}:=\{\bigcup_{r\in\mathbf{R}}r^\mathcal{I}(x)\}$, every concept $C$ occurring in $c$ to $C^{\mathcal{I}_x}:=C^\mathcal{I}\cap \mathcal{U}^{\mathcal{I}_x}$ and every role name $r$ occurring in $c$ to $r^{\mathcal{I}_x}:=r^\mathcal{I}(x)$.\\
$\mathcal{I}$ is a model of $\mathcal{A}$ iff
\begin{itemize}
\item $x:C$ iff $x^\mathcal{I}\in C^\mathcal{I}$ 
\item $(x,y):r$ iff $(x^\mathcal{I},y^\mathcal{I})\in r^\mathcal{I}$
\end{itemize} 
\end{mydef}
Note that in a concept $succ(c)$ $c$ can also be a cardinality constraint over $A\sqcap B$ and $A\sqcup B$. Since the semantic of $A\sqcap B$ and $A\cap B$ (analogously for $A\sqcup B$ and $A\cup B$) are the same, we take the assumption, that every $\sqcap$ and $\sqcup$ within a $succ(c)$ concept are replaced with $\cap$ and $\cup$.
\section{Tableau for $\mathcal{ALCSCC}$}
A Tableau-algorithm consist of completion rules to decide satisfiability of a set of assertions. The rules are applied exhaustively on the set until none is applicable any more. One major characteristic of this algorithm is that it does not matter in which order the rules are applied. Another characteristic is that it works non-deterministically: In case we have disjunctions we can choose between the concepts in this disjunctions. If a choice ends in a \textit{clash} then we track back to the point where we had to chose and take the other choice instead. If all choices ends in a clash then the ABox is unsatisfiable, otherwise it is satisfiable.\\
We want to use the Tableau-algorithm to check whether an assertion $x:C$ is satisfiable or not and if it satisfiable we want to create a satisfied ABox from $x:C$.\\
To help the algorithm we want to avoid nested negation e.g. $\neg(\neg(\neg(A\cup B)))$. Hence we consider all concepts in \textit{negated normal form (NNF)}.
\begin{mydef}[Negation Normal Form]
A $\mathcal{ALCSCC}$ concept is in \textit{negation normal form} ($NNF$) if the negation sign $\neg$ appears only in front of a concept name or above a role name. Let $C$ be a arbitrary $\mathcal{ALCSCC}$ concept. With $NNF(C)$ we denote the concept which is obtained by applying the rules below on $C$ until none is applicable any more.
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $\neg\top$ $\rightarrow$ $\perp$
\item $\neg\perp$ $\rightarrow$ $\top$
\item $\neg\neg C$ $\rightarrow$ $C$
\item $\neg(C\sqcap D)$ $\rightarrow$ $\neg C \sqcup \neg D$
\item $\neg(C\sqcup D)$ $\rightarrow$ $\neg C \sqcap \neg D$
\item $C^\neg$ $\rightarrow$ $\neg C$
\item $\neg succ(c)$ $\rightarrow$ $succ(\neg c)$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $\neg (k\leq l)$ $\rightarrow$ $l\leq k$
\item $\neg (n\text{ } dvd \text{ } k)$ $\rightarrow$ $n\text{ } \neg dvd \text{ } k$
\item $\neg (n\text{ } \neg dvd \text{ } k)$ $\rightarrow$ $n\text{ } dvd \text{ } k$
\item $(s\cap t)^\neg$ $\rightarrow$ $s^\neg \cup t^\neg$
\item $(s\cup t)^\neg$ $\rightarrow$ $s^\neg \cap t^\neg$
\item $(s^\neg)^\neg$ $\rightarrow$ $s$
\end{itemize}
\end{minipage}
\end{figure}
\end{mydef}
The rule $C^\neg\rightarrow \neg C$ is necessary because $C^\neg$ can be a result of $s^\neg$, where $s$ is a set term. It can be transformed into $\neg C$: For every interpretation $\mathcal{I}$ of $S$ we have $(C^\neg)^\mathcal{I}=\mathcal{U}\backslash C^\mathcal{I}$ and $(\neg C)^\mathcal{I}=\Delta^\mathcal{I}\backslash C^\mathcal{I}$. Since $\mathcal{U}\subseteq \Delta$ we can conclude that every element in $(C^\neg)^\mathcal{I}$ is also in $(\neg C)^\mathcal{I}$.\\
The first five rules on the left hand side can be applied in linear time \cite{1},\cite{6}. The first four rules on the right hand side, $C^\neg\rightarrow \neg C$ and $\neg succ(c)\rightarrow succ(\neg c)$ can also be applied in linear time since we only shift the negation sign. the rule $(s^\neg)^\neg\rightarrow s$ works similarly to $\neg\neg C\rightarrow C$ and the rules $(s\cap t)^\neg\rightarrow s^\neg\cup t^\neg$ and $(s\cup t)^\neg\rightarrow s^\neg \cap t^\neg$ works the similarly to $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and can also be applied in linear time.\\
Next we introduce \textit{induced interpretation} with which we can count successors of variables after any rule application.
\begin{mydef}[Induced Interpretation]
An interpretation $\mathcal{I}(\mathcal{A})$ can be induced from an ABox $\mathcal{A}$ by the following steps:
\begin{itemize}
\item for each variable $x\in Var(\mathcal{A})$ we introduce $x^{\mathcal{I}(\mathcal{A})}$ and add it to $\Delta^{\mathcal{I}(\mathcal{A})}$
\item for each $x:C$ such that $C$ is a concept name we add $x^{\mathcal{I}(\mathcal{A})}$ to $C^{\mathcal{I}(\mathcal{A})}$
\item for each $(x,y):r$ such that $r$ is a role name we add $(x^{\mathcal{I}(\mathcal{A})},y^{\mathcal{I}(\mathcal{A})})$ to $r^{\mathcal{I}(\mathcal{A})}$
\end{itemize}
\end{mydef}
Since we can now denote the number of successor of a variable $x$ we can determine which assertion of the form $x:succ(c)$ are violated.
\begin{mydef}[Violated assertion]
Let $\mathcal{A}$ be a set of assertion, $x$ be a variable, $k$ be a cardinality term and $n\in\mathbb{N}$. An assertion $x:succ(c)$ is \textit{violated} if $x^{\mathcal{I}(\mathcal{A})}\notin succ(c)^{\mathcal{I}(\mathcal{A})}$.
\end{mydef}
Like already mentioned an ABox is unsatisfiable if all choices ends in a clash.
\begin{mydef}[Clash]
An ABox $\mathcal{A}$ contains a \textit{clash} if
\begin{itemize}
\item $\{x:\perp\}\subseteq \mathcal{A}$ or
\item $\{x:C,\,x:\neg C\}\subseteq \mathcal{A}$ or
\item $\{x:succ(c)\}\subseteq \mathcal{A}$ violated and no more rules are applicable
\end{itemize}
\end{mydef}
\iffalse
\subsection{The form of the ABox}
Like already mention a ABox $S$ in $\mathcal{ALCSCC}$ contains assertions of the form $x:C$ and $(x,y):C$ where $C$ is a $\mathcal{ALCSCC}$ concept and $x,y\in Var(S)$ are variables. Like already discussed we want constraints to be in $NNF$ and for an assertion $x:succ(c)$ that $c$ is either $k\leq l$ or $n\,dvd\,l$.
Our desired form for the ABox is gained by the following algorithm.
\begin{algorithm}[H] \caption{Transforming ABox}
\begin{algorithmic}[l]
\State ABox $S$
\ForEach {assertion $x:succ(c)\in S$}
\If {$c$ is $s_1\subseteq s_2$}
\State $c:=|s_1\cap s_2^\neg|\leq 0$; return;
\EndIf
\If{$c$ is $s_1\supseteq s_2$ and a set term constraint}
\State $c:=|s_1^\neg\cap s_2|\leq 0$; return;
\EndIf
\If{$c$ is $s_1=s_2$}
\State remove $x:succ(c)$;
\State add $x:succ(|s_1\cap s_2^\neg|\leq 0)$ and $x:succ(|s_1^\neg\cap s_2|\leq 0)$; return;
\EndIf
\If{$c$ is $l>k$}
\State $c:=k +1\leq l$; return;
\EndIf
\If{$c$ is $k<l$}
\State $c:=k +1\leq l$; return;
\EndIf
\If{$c$ is $l\geq k$}
\State $c:=k\leq l$; return;
\EndIf
\If{$c$ is $l=k$ and a cardinality constraint}
\State remove $x:succ(c)$;
\State add $x:succ(l\leq k)$ and $x:succ(k\leq l)$; return;
\EndIf
\EndFor\\
\ForEach{assertion $x:C$ or $(x,y):s$}
\State $C:=NNF(C)$ or $s:=NNF(s)$;
\EndFor
\end{algorithmic}
\end{algorithm}
The first part of the transformation runs in worst case in polynomial time: If any of the first four conditions holds, we only replace $c$ which runs in constant time.  The complexity of a removing function depends on the implementation: If we have direct access to the elements in the ABox the remove function has a constant (runtime) complexity. If we have some kind of sorting then the (runtime) complexity is logarithm. In worst case if we the ABox is stored as a simple list, then the (runtime) complexity is linear. Hence in worse cast the first part runs in polynomial time. The second part always runs in polynomial time because each transformation into $NNF$ runs in linear time. Hence our desired form of the ABox can be obtained in a polynomial time.
\fi
\subsection{Transforming an ABox into a formula}
Dealing with numerical arithmetic is challenging and hence we use the help of a $QFBAPA$ solver, whenever we want to add successors for a variable $x$. For that we collect all $succ$-assertion regarding $x$ first and then transform them into a $QFBAPA$ formula for one \textit{nested level}. We assume that the ABox is already in $NNF$. As example we look at
\begin{ex}[Example for transforming ABox into $QFBAPA$ formula]
\begin{align*}
\mathcal{A}=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|), x:succ(|A|\leq |B|), x:C\}
\end{align*}
\end{ex}
with $\mathbf{C}=\{A,B,C\}$ and $\mathbf{R}=\{r\}$
We first gather all $succ$-assertion regarding $x$ together and transform it into a formula by doing the following steps:
\begin{itemize}
\item drop all $x:succ$
\item replace all role names $r$ with $X_r$
\item replace all concepts names $C$ with $X_C$
\item replace all $succ(c)$ with $X_{c}$
\item connect all formulas with $\wedge$
\item include the conjunct $\mathcal{U}=X_{r_1}\cup\dots\cup X_{r_n}$, $r_1,\dots, r_n\in\mathbf{R}$
\end{itemize}
We replace (possible compound) concepts and role names with set variables, for which a solver can assign elements to them. The last bullet point is important because sometimes it is not explicitly stated, what kind of successor a variable has. However with this naive way we do not see whether the set variables are overlapping or not. Therefore we consider \textit{Venn regions}, which is of the form $X^i_1\cap \dots X^i_k$. The subscript $i$ denotes either $0$ or $1$. $X^0_1$ denotes $X^\neg_1$ and $X^1_1$ denotes $X_1$.\\
For our example we have four set variables: $X_A$, $X_B$, $X_r$ and $X_{|A|\leq |B\cap r|}$. The set variable $X_A$ includes all Venn region, in which $X_A$ occurs. Same goes for the other set variables.\\
The $QFBAPA$ formula for Example 1 is 
\begin{align*}
\phi(x)=1\leq |X_{|A|\leq |B\cap r|}|\wedge |X_A|\leq |X_B|\wedge \mathcal{U}=X_r
\end{align*}
We only replace concepts on one \textit{nested level}. In the example the first assertion tells that $x$ must have at least one successor $y$ which has more successors in $B\cap r$ than in $A$. The concept $succ(|A|\leq|B\cap r|)$ is on a different \textit{nested level} then $succ(|A|\leq |B|)$. According to one solution of the solver we can introduce variables and assertion. Also $x$ has more successor in $B$ than in $A$. By the last conjunction we give the information, that every successor must be an $r$-successor. Then in the upcoming steps, we can gather all $succ$-assertion of the new variables again and repeat this step.
\subsection{Solution of a formula}
For our algorithm we assume that we have a solver, which can return all possible solution. However there can be infinite many solution. Actually Example 1 can have infinitetly many solution: We can always increase the amount of successors in $B$ as long as we have fewer successors in $A$. However not all solutions are desired ones, e.g. we do not need a solution where we have a thousand successors in $B$ if a hundred are also enough. Or we can add just $r$-successors, which are neither in $A$ nor in $B$ even though it satisfies none of the constraint. Therefore we want to only consider solution inside some \textit{upper bounds}. The problem to bound the solution is transferable to the \textit{Integer Linear Programming} (ILP) problem, for which upper bounds are investigated already (like in \cite{knapsack}). Therefore we want to transform our formula into a \textit{linear system of equalities} in a form $Ax=b$:\\
We arrange the inequalities into a form of $X_1\pm \dots \pm X_n\leq I$ or $X_1\pm \dots \pm X_n\geq I$, $I\in\mathbb{Z}$, first. Let $c=|A|\leq |B\cap r|$. $\phi(x)$ is arrange into
\begin{align*}
\phi(x)=|X_{c}|\geq 1\wedge |X_A|- |X_B|\leq 0 \wedge \mathcal{U}-X_r=0
\end{align*}
For 
Then we change each inequalities into equalities by adding values:
\begin{align*}
\phi(x)=|X_{c}|- I_1= 1\wedge |X_A|-|X_B|+I_2= 0 \wedge \mathcal{U}-X_r=0
\end{align*}
Since we have four set variables, we have $2^4=16$ Venn region and therefore $16$ vectors denoting the Venn regions. We also have two equation which means we need at most two more vectors. The matrix $A$ therefore has two rows and 18 columns and $a_{ij}$, $1\leq i\leq 2$ and $1\leq j\leq 16$, denotes the sum of the pre-factors of set variables in the $i$-th equation, where the $j$-th Venn region is included in that set variable. We already see that the number of Venn regions grows exponentially with the number of set variables. In \cite{4} it is stated that there exists a number $N$, which is polynomial in size of $\phi$, such that at most $N$ Venn regions are not empty, if there exists a solution.
\begin{mylem}[Lemma 3 from \cite{4}]
For every $QFBAPA$ formula $\phi$ a number $N$, which is polynomial to the size of $\phi$, can be computed in polynomial time such that for every solution $\sigma$ of $\phi$ there exists a solution $\sigma^\prime$ of $\phi$ such that
\begin{itemize}
\item $|\{v|v\text{ is a Venn region and }\sigma^\prime(v)\neq \emptyset\}|\leq N$
\item $|\{v|v\text{ is a Venn region and }\sigma^\prime(v)\neq \emptyset\}|\subseteq |\{v|v\text{ is a Venn region and }\sigma^\prime(v)\neq \emptyset\}|$
\end{itemize}
\end{mylem}
Hence we guess (in non-deterministic polynomial time) a number $N$ of Venn regions, which are non-zero. In Example 1 we can already guess, that any Venn region within $X_r^\neg$ must be empty, because $\mathcal{U}=X_r$. Hence we can drop eight Venn regions and create the following system of equation. Let the vectors for the Venn regions be in the following order:
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $v_1=X_A\cap X_B\cap X_c\cap X_r$
\item $v_2=X_A\cap X_B\cap X_c^\neg\cap X_r$
\item $v_3=X_A\cap X_B^\neg\cap X_c\cap X_r$
\item $v_4=X_A\cap X_B^\neg\cap X_c^\neg\cap X_r$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $v_5=X_A^\neg\cap X_B\cap X_c\cap X_r$
\item $v_6=X_A^\neg\cap X_B\cap X_c^\neg\cap X_r$
\item $v_7=X_A^\neg\cap X_B^\neg\cap X_c\cap X_r$
\item $v_8=X_A^\neg\cap X_B^\neg\cap X_c^\neg\cap X_r$
\end{itemize}
\end{minipage}
\end{figure}
We create now the linear system of equation:
\begin{align*}
\left ( \begin{array}{cccccccccc}
1&0&1&0&1&0&1&0&1&0\\
0&0&1&1&-1&-1&0&0&0&1
\end{array} \right )\left ( \begin{array}{c}
x_1\\x_2\\x_3\\x_4\\x_5\\x_6\\x_7\\x_8
\end{array}\right )=\left ( \begin{array}{cc}
1&0
\end{array}\right )
\end{align*}
Note that $a_{2,1}$ and $a_{2,2}$ are $0$ because the pre-factor of $X_A$ and $X_B$ are $1$ and $-1$ and because the Venn regions $v_1$ and $v2$ are included both in $X_A$ and $X_B$. If $x_i=0$ then the Venn region $v_i$ is empty.\\
Going back to upper bound problem: In \cite{knapsack} the calculated upper bound for each $x_i$ is $n\cdot (m\cdot max_{i,j}\{|a_{ij}|,|b_i|\})^{2\cdot m+1}$, where $A$ is a $m\,\times\,n$ matrix, $b$ a vector of $\mathbb{Z}^m$  and $1\leq i\leq m$, $1\leq j\leq n$. More precisely
\begin{mythe}[Theorem 1 from \cite{knapsack}]
Let $A\in \mathbb{N}^m\times \mathbb{N}^n$ be a matrix and $b\in\mathbb{N}^m$ a vector. If $x\in\mathbb{N}^n$ is a solution of $Ax=b$, then there exists a solution $x^\prime$ such that all entries are integers between $0$ and $n\cdot (m\cdot max_{i,j}\{|a_{ij}|,|b_i|\})^{2\cdot m+1}$.
\end{mythe}
For finding a solution $x^\prime$ the entries of the found solution $x$ are decreased. We distinguish between two cases. Let $M=m\cdot max_{i,j}\{|a_{ij}|\}^m$, $F=\{i|x_i>M\}$ and $v_i$ be the $i$-th column of $A$
\begin{itemize}
\item If there exists integers $\alpha_i$, for all $i\in F$, such that $\sum_{i\in F}\alpha_i\cdot v_i=0$ and $\exists i: \alpha_i>0$ then $x^\prime=x-d$, $d_j=\alpha_j$ if $j\in M$ else $d_j=0$, $1\leq j\leq n$.
\item Else: There must be a vector $h\in\{0,\pm 1,\pm 2,\dots \pm M\}^m$ such that $h^T v_i\geq1, i\in F$. We premultiply $A$ and $b$ with $h^T$ for which the solution is within our bound:
\begin{align*}
h^TA x^\prime = h^Tb
\end{align*}
\end{itemize}
(proof in \cite{knapsack})\\
In our example the upper bound for all $x_i$ is $8\cdot (2\cdot max_{i,j}\{|1|,|-1|\})^{2\cdot 2+1}=512$. Therefore we can bound our number of elements in each Venn regions to $512$. 
\subsection{Algorithm}
Finally we can present the Tableau-algorithm for an ABox in $\mathcal{ALCSCC}$. We describe above how we handle the numeric arithmetic of $\mathcal{ALCSCC}$ and that we want to decompose compound concept first. Hence we divide the algorithm in two parts: a boolean part, where the decomposing of compound concepts takes place, and a numerical part, where a part of the ABox is transformed into a $QFBAPA$ formula and a solver returns a possible assignment of elements. The boolean part has a higher priority than the numerical part.
\begin{mydef}[Tableau]
Let $\mathcal{A}$ be a set of assertions in $NNF$.\\
Boolean part:
\begin{itemize}
\item\label{cap} $\sqcap$-rule: $\mathcal{A}$ contains $x:C_1\sqcap C_2$ but not both $x:C_1$ and $x:C_2$\\
$\rightarrow$ $\mathcal{A}:=\mathcal{A}\cup\{x:C_1, x:C_2\}$
\item\label{cup} $\sqcup$-rule: $\mathcal{A}$ contains $x:C_1\sqcup C_2$ but neither $x:C_1$ nor $x:C_2$\\
$\rightarrow$ $\mathcal{A}:=\mathcal{A}\cup\{x:C_1\}$ or $\mathcal{A}:=\mathcal{A}\cup\{x:C_2\}$
\end{itemize}
Numerical part:
\begin{itemize}
\item\label{succ} $successor$-rule: $\mathcal{A}$ contains for a variable $x$ at least one violated assertion of the form $x:succ(c)$:
\begin{itemize}
\item gather all assertion of the form $x:succ(c)$ into a set $\mathcal{S}$
\item transform $\mathcal{S}$ into a $QFBAPA$ formula $\mathcal{F}(S)$
\end{itemize}
If a $QFBAPA$ solver returns \textit{unsatisfiable} then $\mathcal{A}=\mathcal{A}\cup\{x:\perp\}$\\
If a $QFBAPA$ solver returns \textit{satisfiable} then select one solution $\sigma$ and for each $e\in E(\sigma)$ we introduce a new variable $y$ and
\begin{itemize}
\item for each $e\in X_C$ we have $\mathcal{A}=\mathcal{A}\cup\{y:C\}$
\item for each $e\in X_{c}$, $c$ is a cardinality constraint, we have $\mathcal{A}=\mathcal{A}\cup\{y:succ(c)\}$
\item for each $e\in X_r$, $r\in\mathbf{R}$, we have $\mathcal{A}=\mathcal{A}\cup\{(x,y):r\}$
\end{itemize}
\end{itemize}
\end{mydef}
A \textit{complete} ABox is an ABox, on which no more rules of the Tableau-algorithm are applicable.\\
We pick up Example 1 again but in a form where it is not decomposed yet:
\begin{align*}
\mathcal{A}=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|)\sqcap succ(|A|\leq |B|)\sqcap C, (x,y):B\cap r\}
\end{align*}
We are able to apply the boolean rules and hence we apply them first and decompose into Example 1. Then we apply the $successor$-rule: We collect every $succ$-assertion regarding $x$ to a set $\mathcal{S}:=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|), x:succ(|A|\leq |B|)\}$ and convert $\mathcal{A}$ to the $QFBAPA$ formula $1\leq X_{|A|\leq|B\cap r|}\wedge|X_A|\leq |X_B|\wedge \mathcal{U}=\{X_r\}$. Then we let a solver returns an assignment if possible. In this case we see that the formula is satisfiable with $X_{|A|\leq|B\cap r|}=\{f\},X_A=\{\},X_B=\{e\}$ and $X_r=\{e,f\}$. Since we have $\mathcal{U}=\{X_r\}$ every element must be in $X_r$. That means that every successor is connected to its predecessor by a role name and in our example every successor is a $r$-successor. We then introduce for $e$ ans $f$ two variables $y$ and $z$ and the assertion $y:X_B$, $(x,y):r$, $z:succ(|A|\leq|B\cap r|)$ and $(x,z):r$ to $S$. Then for $z$ we have to apply the $successor$-rule again.
\section{Correctness}
For the correctness proof of the Tableau-algorithm we have to show that
\begin{itemize}
\item If no more rules are applicable on a clash-free ABox $\mathcal{A}$ then $\mathcal{A}$ is satisfiable
\item If $\mathcal{A}$ is satisfiable then the Tableau-algorithm terminates without a clash
\item For every input the Tableau-algorithm terminates
\end{itemize}
In all proves we assume that the $QFBAPA$ solver is correct. First we prove that the algorithm works correctly e.g. we prove the first two points. 
\begin{mylem}
If the Tableau-algorithm is applied on an ABox $\mathcal{A}=\{x:C\}$ and  terminates without a clash then $\mathcal{A}$ is satisfiable
\end{mylem}
\begin{proof}
Let $\mathcal{A}^\prime$ be the result after the algorithm terminated. Since we do not remove any assertion during the algorithm we have $\mathcal{A}\subseteq\mathcal{A}^\prime$. Hence if an interpretation $\mathcal{I}$ satisfies $\mathcal{A}^\prime$ then it also satisfies $\mathcal{A}$. Let $\mathcal{I}(\mathcal{A}^\prime)$ be the induced interpretation of $\mathcal{A}^\prime$. We show that $\mathcal{I}(\mathcal{A}^\prime)$ indeed satisfies $\mathcal{A}^\prime$ by induction over concepts:\\
For each concept name $C\in\mathbf{C}$ such that $x:C\in\mathcal{A}^\prime$, we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}$ by the definition of induced interpretation. (induction base)\\
We consider $x:C$ where $C$ is a compound concepts (induction step):
\begin{itemize}
\item $C=\neg D$: Since $\mathcal{A}^\prime$ does not contain a clash, $x:C\in A$ implies $x:D\notin A$. $D$ must be a concept name, because $\mathcal{A}^\prime$ is in $NNF$. Therefore by definition of induced interpretation and $x:D\notin A$ we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\notin D^{\mathcal{I}(\mathcal{A}^\prime)}$ which implies $x^{\mathcal{I}(\mathcal{A}^\prime)}\in \Delta^{\mathcal{I}(\mathcal{A}^\prime)}\backslash D^{\mathcal{I}(\mathcal{A}^\prime)}=C^{\mathcal{I}(\mathcal{A}^\prime)}$.
\item $C=D\sqcap E$: Since the algorithm terminated, the $\sqcap$-rule is not applicable any more. That means that there is a variable $x$, such that $\{x:D, x:E\}\subseteq \mathcal{A}^\prime$. By the induction hypothesis we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in D^{\mathcal{I}(\mathcal{A}^\prime)}$ and $x^{\mathcal{I}(\mathcal{A}^\prime)}\in E^{\mathcal{I}(\mathcal{A}^\prime)}$. Therefore $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}\cap D^{\mathcal{I}(\mathcal{A}^\prime)}=(C\sqcap D)^{\mathcal{I}(\mathcal{A}^\prime)}$.
\item $C=D\sqcup E$: Since the algorithm terminated, the $\sqcup$-rule is not applicable any more. That means that there is a variable $x$, such that $\{x:D, x:E\}\cap \mathcal{A}^\prime\neq \emptyset$. By the induction hypothesis we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in D^{\mathcal{I}(\mathcal{A}^\prime)}$ or $x^{\mathcal{I}(\mathcal{A}^\prime)}\in E^{\mathcal{I}(\mathcal{A}^\prime)}$. Therefore $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}\cup D^{\mathcal{I}(\mathcal{A}^\prime)}=(C\sqcup D)^{\mathcal{I}(\mathcal{A}^\prime)}$.
\item $C=succ(c)$: Since $\mathcal{A}^\prime$ does not contain a clash, the $QFBAPA$ solver must have returned a solution. If the solution is empty, then no variables are needed to be introduced to satisfy $x:C$ and we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}$. If the solution is not empty then the induced interpretation is updated by introducing a new element $y^{\mathcal{I}(\mathcal{A}^\prime)}$ for each $e\in E(\sigma)$ and hence also for each freshly introduced variable $y$. For each $e\in X_C$ we have $y:C\in \mathcal{A}^\prime$. By the induction hypothesis $y^{\mathcal{I}(\mathcal{A}^\prime)}$ must be in $C^{\mathcal{I}(\mathcal{A}^\prime)}$. For each $e\in X_r$ we have $(x,y):r$. By the induction step we know there must be an element $x^{\mathcal{I}(\mathcal{A}^\prime)}\in\Delta1^{\mathcal{I}(\mathcal{A}^\prime)}$. Because we introduced $e$ in this step, we also introduced a new variable $y$ which means for the induced interpretation we introduce a new element $y^{\mathcal{I}(\mathcal{A}^\prime)}$. Since we also added $(x,y):r$ to $\mathcal{A}^\prime$, we must have $(x^{\mathcal{I}(\mathcal{A}^\prime)},y^{\mathcal{I}(\mathcal{A}^\prime)})\in r^{\mathcal{I}(\mathcal{A}^\prime)}$. Lastly for each $e\in X_c$, $c$ is a cardinality constraint, we have $y:succ(c)$. Again by the induction hypothesis $y^{\mathcal{I}(\mathcal{A}^\prime)}\in succ(c)^{\mathcal{I}(\mathcal{A}^\prime)}$. Since the solution is correct, we know that $x^{\mathcal{I}(\mathcal{A}^\prime)}\in succ(c)^{\mathcal{I}(\mathcal{A}^\prime)}$.
\end{itemize}
Since we know that $\mathcal{I}(\mathcal{A}^\prime)$ satisfies $\mathcal{A}^\prime$ and that $\mathcal{A}\subseteq \mathcal{A}^\prime$, $\mathcal{I}(\mathcal{A}^\prime)$ also satisfies $\mathcal{A}$.
\end{proof}
\begin{mylem}
If $\mathcal{A}:=\{x:C\}$ is satisfiable then the Tableau-algorithm terminates without a clash.
\end{mylem}
\begin{proof}
Since $\mathcal{A}$ is satisfiable it does not contain a clash. Let $\mathcal{I}=(\Delta^\mathcal{I},\cdot^\mathcal{I})$ be an interpretation, which satisfies $\mathcal{A}$. We show, that if $\mathcal{A}_i$ does not contain a clash and $\mathcal{I}$ satisfies $\mathcal{A}_i$, then $\mathcal{A}_{i+1}$ can be obtained from $\mathcal{A}_i$ by applying a rule while maintaining clash-free and satisfied by $\mathcal{I}$.\\
We already stated that $\mathcal{I}$ satisfies the clash-free $\mathcal{A}=:\mathcal{A}_{0}$. (induction base).
Let $\mathcal{A}_i$ be a clash-free ABox, which is satisfied by $\mathcal{I}$. (induction hypothesis).
We distinguish the cases based on the rules, we apply on $\mathcal{A}_i$ to obtain $\mathcal{A}_{i+1}$ (induction step):
\begin{itemize}
\item we apply the $\sqcap$-rule on $x:C\sqcap D$: The interpretation $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}:=\mathcal{A}_i\cup\{x:C,x:D\}$ because by the hypothesis $\mathcal{I}$ already satisfies $\mathcal{A}_i$ and hence also $x:C\sqcap D$. That means that $x^\mathcal{I}\in(C\sqcap D)^\mathcal{I}$ and therefore $\{x,C,x:D\}\cup\mathcal{A}_i$ is satisfied by $\mathcal{I}$
\item we apply the $\sqcup$-rule on $x:C\sqcup D$: We have to show that either $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:C\}$ or $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:D\}$ is satisfied by $\mathcal{I}$. Again by the induction hypothesis $\mathcal{A}_i$ is satisfied by $\mathcal{I}$ and hence $x^\mathcal{I}=(C\sqcup D)^\mathcal{I}$. So either we choose $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:C\}$ and hence $x^\mathcal{I}\in C^\mathcal{I}$ or we choose $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:D\}$ and hence $x^\mathcal{I}\in D^\mathcal{I}$. In both cases $x^\mathcal{I}\in C^\mathcal{I}\cup D^\mathcal{I}=(C\sqcup D)^\mathcal{I}$ and hence $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$.
\item we apply the $succ$-rule on $x:succ(c)$: By the induction hypothesis we have $x^\mathcal{I}\in succ(c)^\mathcal{I}$. We have to show that by this step we are able to add successors, such that $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$. In this step, we gather first all $succ$-assertion together, formulate a $QFBAPA$ formula $\phi(x)$ and let a solver return us all possible solution with in an upper bound. Because $\mathcal{A}_i$ is satisfiable, the $succ$-assertions together are also satisfiable (subset of $\mathcal{A}$). Hence there has to be solutions which can be returned by the solver. We need to show, that the solver is capable to return a solution within our upper bound, such that $\mathcal{A}_{i+1}$ is satisfied by $\mathcal{I}$. In case $x^\mathcal{I}$ has no successors, the empty solution $\sigma$ with $E(\sigma)=\emptyset$ must be a valid solution, which can be returned from the solver. If $\mathcal{I}$ is finite and within our upper bound, then we can create a solution $\sigma^\ast$ induced by $\mathcal{I}$, which can be returned by our solver. In any other case we have to show, that we can reduce the solution induced by $\mathcal{I}$. \textcolor{red}{todo}.
Therefore we are able to pick a solution, such that $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$.
\end{itemize}
\end{proof}
We know that a subset of a satisfiable ABox $\mathcal{A}$ is also satisfiable because the induced interpretation $\mathcal{I}(\mathcal{A})$, which satisfies $\mathcal{A}$, satisfies all subsets of $\mathcal{A}$.\\
We now prove that the algorithm terminates. For that we define first the depth \textcolor{red}{and size?} of a concept $C$:
\begin{align*}
depth(C):=\begin{cases}
1+depth(c) & C=succ(c) \\
0 & \, \text{otherwise}
\end{cases}
\end{align*}
This function is well-define because by Definition 3 our concepts are inductively defined from concept names, hence the $depth$-function always returns an integer.
\begin{mylem}
The Tableau-algorithm always terminate for an ABox $\mathcal{A}=\{x:C\}$
\end{mylem}
\begin{proof}
???
\end{proof}
\normalem
\bibliographystyle{abbrv}
\bibliography{ref}
\end{document}
