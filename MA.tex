\documentclass[a4paper,11pt]{scrartcl}
\usepackage[english]{babel}  % falls der Artikel auf Deutsch verfasst ist
% Verwenden Sie nur EINE der beiden folgenden Zeilen, je nachdem, ob Ihr
% Betriebssystem LATIN1 (=ISO-8859-1) oder UTF8 als Zeichenkodierung
% verwendet. Ob Sie die richtige verwenden, merken Sie daran, dass
% die Umlaute richtig im Dokument dargestellt werden.
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{dsfont}
\usepackage{float}
\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {\itshape}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
\theoremstyle{definition}
\newtheorem{mydef}{Definition}
\newtheorem{mylem}{Lemma}
\newtheorem{mythe}{Theorem}
\newtheorem{mycol}{Corollary}
\newtheorem{mypro}{Proposition}
\newtheorem{ex}{Example}
\usepackage{color}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes,arrows}
\usepackage{verbatim}
\usetikzlibrary{positioning}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{pgfplots}
\pgfplotsset{compat=1.8}
\usetikzlibrary{patterns}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\usepackage{ulem}
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}
\usepackage{url}
\makeatletter
\newcommand{\oset}[3][0ex]{%
  \mathrel{\mathop{#3}\limits^{
    \vbox to#1{\kern-2\ex@
    \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother
\pgfplotsset{
    standard/.style={
        axis x line=middle,
        axis y line=middle,
        enlarge x limits=0.1,
        enlarge y limits=0.15,
        every axis x label/.style={at={(current axis.right of origin)},anchor= north west},
        every axis y label/.style={at={(current axis.above origin)},anchor= east}
    }
}
\begin{document}
\tableofcontents
\newpage
\section{Introduction}
Traditional data bases where data are stored solely without any connection towards to themselves like many people would imagine are often not enough any more. The reason is that the data are stored without any semantics. However storing data with semantics can provide additional information. For example we have some data about two objects \textit{"Anna"} and \textit{"Beth"}. In a traditional data base if not explicitly stated, both data are not related to each other. Nethertheless Anna and Beth can have a relation, which also depends on who or what both are. For example both can be human and Anna is a teacher and Beth is a student. Both are in the same class. By adding solely those information in a traditional data base the information that Anna must teaches Beth is not given. One way to apply semantics to data objects is to use \textit{ontologies}. In biological and (bio)medical researches data bases are often based on ontologies \cite{bio}. Ontologies (in the computer science field) can be viewed as formal representation of a certain domain of interest. In data base they are collection of relation between the entities in the data base and are formulated as a fragment of first-order logic (FOL). These fragments of FOL are represented as \textit{Description Logic (DL)}, which is a family of knowledge representation system. DL are mainly built of concepts, which correspond to unary relations in FOL and is often represented by a capital letter, and relation between the concepts, which correspond to binary relations in FOL and is often represented by a lowercase letter. For more complex (compound) concepts operators like $\sqcap$, $\sqcup$,$\sqsubseteq$, $\exists$ and $\forall$, depending on the DL, are used. For example the statement "All Men and Women are Human" is formalize in FOL as $\forall x.Men(x)\vee Women(x)\rightarrow Human(x)$ and in DL as an \textit{axiom} $Men\,\sqcup\, Women\sqsubseteq Human$, where $Men$,$Women$ and $Human$ are concept names. The statement "All Humans, who have children, are parents" can be formalized in FOL as $\forall x \exists y. Human(x)\wedge hasChildren(x,y)\rightarrow Parent(x)$ and in DL as $Human\sqcap \exists hasChildren.\top \sqsubseteq Parent$, where $Human$ and $Parents$ are concept names and $hasChildren$ is a role name. Restriction with the operators $\exists$ and $\forall$ are called \textit{quantified} restrictions. The second statement can also be formalized with a \textit{qualified} restriction: $Human\sqcap \geq 1 hasChildren.\top\sqsubseteq Parent$. Each quantified restriction can be transformed into a qualified restriction.\\
One big research field in DL is the determination of satisfiability of an \textit{knowledge base}, which is formulated in DL. A knowledge base normaly consists of a \textit{TBox}, which contains the axioms (rules), and of an \textit{ABox} which contains assertions of certain elements (objects). This DL allows conjunctions ($\sqcap$), disjunctions ($\sqcup$), negation $\neg C$ and qualifying number restriction ($\leq\,n\,r\, C$ and $\geq \, n\, r\, C$), where $n$ is a number, $r$ a role name, and $C$ a concept name. In \cite{1} a \textit{Tableau}-algorithm is presented for checking satisfiability for an ABox in the DL $\mathcal{ALCQ}$. A Tableau-algorithm applies \textit{completion rules} to a given \textit{set}(ABox) to decompose complex concepts and try satisfiying violated \textit{statements}(assertions). If the set concludes something unsatisfiable (clash) then the whole set is unsatisfiable. If no more rules are applicable and the set is not unsatisfiable, then it is otherwise. The satisfiability (of concepts) is stated in \cite{1} as PSPACE-hard problem (without TBox, with TBox it is EXPTime-hard \cite{4}. In \cite{pspace} a optimized Tableau-algorithm is presented which results in a PSPACE-problem. The optimization is that instead of keeping $n$ successors to satisfy a restriction $\geq\,n\,r.C$ like in \cite{1}, the algorithm saves the number of existing successors and by comparing the numbers detects possible clashes. This DL is more expressive than $\mathcal{ALCQ}$ because every qualified restriction $\leq\,n\,r.C$ and $\geq \, n\, r.C$ can be written in $\mathcal{ALCSCC}$ as $succ(|r.C|\leq 1)$ and $succ(|r.C|\geq 1)$. \\
The expressive DL $\mathcal{ALCSCC}$ extends $\mathcal{ALCQ}$ with \textit{set constraint} and \textit{cardinality constrant}, which lays under the logic of \textit{QFBAPA} (quantifier-free fragment of Boolean Algebra with Presburger Arithmetic). As the name says we do not have quantifier. Instead we use set expression (Boolean Algebra part) and numerical constraint (Presburger Arithmetic) which is combined together with cardinality functions. For example $Human\sqcap \geq 1\,hasChildren.\top\sqsubseteq Parent$ is written in $\mathcal{ALCSCC}$ as $Human\sqcap succ(|hasChildren|\geq 1)\sqsubseteq Parent$. In \cite{4} a solution for the satisfiability problem (without TBox) is presented which has the complexity PSpace: For an ABox we guess the value (true or false) of the top-level variables which can already lead to a \textit{false}-result. If not then the constraint is formulated into a $QFBAPA$ formula, for which an algorithm determine by guessing a number $N$ of Venn-region to be non-empty whether the formula is satisfied or not.\\
In this work we give another solution for the satisfiability problem with a Tableau-algorithm. As in previous work for other DLs we define completion rules which can be applied onto assertions in the ABox to determine whether $\perp$ can be concluded from it which states its unsatisfiability. If we can not apply any rules any more and we can not conclude $\perp$, then the ABox is satisfiable. The main difficulty is that unlike $\mathcal{ALCQ}$, where the bond of number of successor is fixed, in $\mathcal{ALCSCC}$ we can compare two cardinalities, which can vary during the algorithm. Hence we need an approach for counting successors and with it calculating the \textit{correct} cardinality, which is necessary to detect satisfied and violated constraint. For this we introduce \textit{induced interpretation} which can determine the cardinalities after each rule application. Further more to deal with the numerical arithmetic of $\mathcal{ALCSCC}$ we use a $QFBAPA$ solver. We transform a subset of the ABox into a $QFBAPA$ formula and then let a solver determine whether the formula is satisfiable or not. If not we end with a clash. If it returns a solution, then we add variables according to it to our ABox.
\section{Preliminaries}
In this work $\mathbf{C}$ denotes a set of concept names and $\mathbf{R}$ a set of role names, which are disjoint. Before we define the DL $\mathcal{ALCSCC}$ we have to explain first how the language $QFBAPA$ looks like.
\begin{mydef}[$QFBAPA$]
Let $T$ be a set of symbols
\begin{itemize}
\item set terms over $T$ are:
\begin{itemize}
\item empty set $\emptyset$ and universal set $
\mathcal{U}$
\item every set symbol in $T$
\item if $s,t$ are set terms then also $s\cap t$, $s\cup t$ and $s^{\neg}$
\end{itemize}
\item set constraints over $T$ are
\begin{itemize}
\item $s\subseteq t$ and $s\not\subseteq t$
\item $s=t$ and $s\neq t$
\end{itemize}
where $s,t$ are set terms
\item cardinality terms over $T$ are:
\begin{itemize}
\item every number $n\in \mathbb{N}$
\item $|s|$ if $s$ is a set term
\item if $k,l$ are cardinality terms then also $k+l$ and $n\cdot k$, $n\in \mathbb{N}$
\end{itemize}
\item cardinality constraints over $T$ are:
\begin{itemize}
\item $k=l$ and $k\neq l$
\item $k<l$ and $k\geq l$
\item $k\leq l$ and $k>l$
\item $n$ $dvd$ $k$ and $n$ $\neg dvd$ $k$
\end{itemize}
where $k,l$ are cardinality terms and $n\in\mathbb{N}$
\end{itemize}
A $QFBABA$ formula are disjunction ($\vee$) and conjunction ($\wedge$) of (also possible negated) cardinality constraints
\end{mydef}
Since $s\subseteq t$ can be expressed as the cardinality constraint $|s\cap t^\neg|\leq 0$ we will not consider any set constraints further in this work. In case we want to express $x:succ(s=t)$, with $s,t$ being set terms, we write instead $x:succ(|s\cap t^\neg|\leq 0)\sqcap succ(|s^\neg\cap t|\leq 0)$. Furthermore instead of $l\geq k$ we write $k\leq l$, instead of $k<l$ we write $k+1\leq l$ and instead of $k=l$ we write $k\leq l$ and $l\leq k$. Hence for an assertion $x:succ(c)$ the cardinality constraint $c$ is either of the form $k\leq l$ or $n\,dvd\,l$.\\
The semantic of $QFBAPA$ is define as follows:
\begin{mydef}[Interpretation of $QFBAPA$]
Let $\Delta^\mathcal{I}$ be a set and $\sigma$ a mapping which maps
\begin{itemize}
\item every symbol $a$ in $T$ to $\sigma(a)$
\item $\emptyset$ to $\sigma(\emptyset)$
\item $\mathcal{U}$ to $\sigma(\mathcal{U})\subseteq \Delta^\mathcal{I}$
\item $\sigma(s\cap t):= \sigma(s)\cap \sigma(t)$, $\sigma(s\cup t):= \sigma(s)\cup \sigma(t)$
\item $\sigma(s^\neg):=\sigma(\mathcal{U})\backslash \sigma(s)$
\item $\sigma(|s|):=|\sigma(s)|$
\item $\sigma(k+l):=\sigma(k)+\sigma(l)$, $\sigma(n\cdot k):= n\cdot \sigma(k)$
\end{itemize}
The mappings satisfies for the cardinality terms $k,l$
\begin{itemize}
\item $k\leq l$ iff $\sigma(k)\leq \sigma(l)$
\item $n\,dvd\,l$ iff $\exists m\in\mathbb{N}:n\cdot m = \sigma(l)$
\end{itemize}
\end{mydef}
Let $\mathbf{C}$ be a set of concept names and $\mathbf{R}$ a set of role names, such that $\mathbf{C}$ and $\mathbf{R}$ are disjoint.
\begin{mydef}[$\mathcal{ALCSCC}$]
$\mathcal{ALCSCC}$ concepts are defined inductively:
\begin{itemize}
\item all concept names
\item $succ(c)$ if $c$ is a cardinality constraint over $\mathcal{ALCSCC}$ concepts and role names
\item if $C,D$ are concepts then:
\begin{itemize}
\item $\neg C$
\item $C\sqcup D$
\item $C\sqcap D$
\end{itemize}
\end{itemize}
\end{mydef}
An ABox $S$ in $\mathcal{ALCSCC}$ is a finite set of assertions of the form $x:C$ and $(x,y):r$, where $C$ is a $\mathcal{ALCSCC}$ concept, $r\in\mathbf{R}$ and $x,y$ are variables. The set $Var(S)$ is the set of variables occurring in $S$. 
\begin{mydef}[Interpretation]
An \textit{interpretation} $\mathcal{I}=(\Delta^\mathcal{I},\cdot^\mathcal{I},\pi_\mathcal{I})$ over an ABox $S$ in $\mathcal{ALCSCC}$ consists of a non-empty set $\Delta^\mathcal{I}$, an assignment $\pi_\mathcal{I}$ and a mapping $\cdot^\mathcal{I}$ which maps:
\begin{itemize}
\item each variable $x\in Var(S)$ to $x^\mathcal{I}\in \Delta^\mathcal{I}$
\item every concept names $A\in\mathbf{C}$ to $A^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item every role name $r\in\mathbf{R}$ to $r^\mathcal{I}\subseteq\Delta^\mathcal{I}\times\Delta^\mathcal{I}$, such that every element in $\Delta^\mathcal{I}$ has a finite number of successors.
\end{itemize}
The set $r^\mathcal{I}(x)$ contains all elements $y$ such that $(x,y)\in r^\mathcal{I}$ e.g. it contains all $r$-successors of $x$.\\
For compound concepts the mapping $\cdot^\mathcal{I}$ is extended inductively as follows
\begin{itemize}
\item $\top^\mathcal{I}=\Delta^\mathcal{I}$ and $\perp^\mathcal{I}=\emptyset^\mathcal{I}$
\item $(C\sqcap D)^\mathcal{I}:=C^\mathcal{I}\cap D^\mathcal{I}$, $(C\sqcup D)^\mathcal{I}:=C^\mathcal{I}\cup D^\mathcal{I}$
\item $(\neg C)^\mathcal{I}:=\Delta^\mathcal{I}\backslash C^\mathcal{I}$
\item $succ(c)^\mathcal{I}=\{x\in \Delta^\mathcal{I}|$the mapping $\cdot^{\mathcal{I}_x}$ satisfies $c\}$
\end{itemize}
The mapping $\cdot^{\mathcal{I}_x}$ maps $\emptyset$ to $\emptyset^\mathcal{I}$, $\mathcal{U}$ to $\mathcal{U}^{\mathcal{I}_x}:=\{\bigcup_{r\in\mathbf{R}}r^\mathcal{I}(x)\}$, every concept $C$ occurring in $c$ to $C^{\mathcal{I}_x}:=C^\mathcal{I}\cap \mathcal{U}^{\mathcal{I}_x}$ and every role name $r$ occurring in $c$ to $r^{\mathcal{I}_x}:=r^\mathcal{I}(x)$.\\
The \textit{assignment} $\pi_\mathcal{I}:Var(S)\rightarrow\Delta^\mathcal{I}$ satisfies
\begin{itemize}
\item $x:C$ iff $\pi_\mathcal{I}(x)\in C^\mathcal{I}$ 
\item $(x,y):s$ iff $(\pi_\mathcal{I}(x),\pi_\mathcal{I}(y))\in s^\mathcal{I}$
\end{itemize} 
$\pi_\mathcal{I}$ satisfies an ABox $S$ if $\pi_\mathcal{I}$ satisfies every assertion in $S$. If $\pi_\mathcal{I}$ satisfies $S$ then $\mathcal{I}$ is a model of $S$.
\end{mydef}
\textcolor{red}{
We say a set term $t$ occurs semantically in a cardinality term $k=n_0+n_1\cdot |s_1|+\dots +n_j\cdot|s_j|$ if for a $i\in\{1,\dots ,j\}$ we have $s_i=t\cup t_{rest}$, where $t_{rest}$ is a set term. Note that a set term $t$ does not occurs semantically in the cardinality term$|t^\neg|$.\\
For the Tableau-algorithm we can apply rules for decomposing concepts, introducing variables, adding assertion and merging variables.
\begin{mydef}[Merge]
\textit{Merging} two variables $y_1$ and $y_2$ in an ABox $S$ results in one variable $y$: replace all occurrence of $y_1$ and $y_2$ with $y$ in $S$. 
\end{mydef}}
\section{Tableau for $\mathcal{ALCSCC}$}
A Tableau-algorithm consist of completion rules to decide satisfiability of a set of assertions. The rules are applied exhaustively on the set until none is applicable any more. One major characteristic of this algorithm is that it does not matter in which order the rules are applied. Another characteristic is that it works non-deterministically: In case we have disjunctions we can choose between the concepts in this disjunctions. If a choice ends in a \textit{clash} then we track back to the point where we had to chose and take the other choice instead. If all choices ends in a clash then the ABox is unsatisfiable, otherwise it is satisfiable.\\
We want to use the Tableau-algorithm to check whether an assertion $x:C$ is satisfiable or not and if it satisfiable we want to create a satisfied ABox from $x:C$.\\
To help the algorithm we want to avoid nested negation e.g. $\neg(\neg(\neg(A\cup B)))$. Hence we consider all concepts in \textit{negated normal form (NNF)}.
\begin{mydef}[Negation Normal Form]
A $\mathcal{ALCSCC}$ concept is in \textit{negation normal form} ($NNF$) if the negation sign $\neg$ appears only in front of a concept name or above a role name. Let $C$ be a arbitrary $\mathcal{ALCSCC}$ concept. With $NNF(C)$ we denote the concept which is obtained by applying the rules below on $C$ until none is applicable any more.
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $\neg\top$ $\rightarrow$ $\perp$
\item $\neg\perp$ $\rightarrow$ $\top$
\item $\neg\neg C$ $\rightarrow$ $C$
\item $\neg(C\sqcap D)$ $\rightarrow$ $\neg C \sqcup \neg D$
\item $\neg(C\sqcup D)$ $\rightarrow$ $\neg C \sqcap \neg D$
\item $C^\neg$ $\rightarrow$ $\neg C$
\item $\neg succ(c)$ $\rightarrow$ $succ(\neg c)$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $\neg (k\leq l)$ $\rightarrow$ $l\leq k$
\item $\neg (n\text{ } dvd \text{ } k)$ $\rightarrow$ $n\text{ } \neg dvd \text{ } k$
\item $\neg (n\text{ } \neg dvd \text{ } k)$ $\rightarrow$ $n\text{ } dvd \text{ } k$
\item $(s\cap t)^\neg$ $\rightarrow$ $s^\neg \cup t^\neg$
\item $(s\cup t)^\neg$ $\rightarrow$ $s^\neg \cap t^\neg$
\item $(s^\neg)^\neg$ $\rightarrow$ $s$
\end{itemize}
\end{minipage}
\end{figure}
\end{mydef}
The rule $C^\neg\rightarrow \neg C$ is necessary because $C^\neg$ can be a result of $s^\neg$, where $s$ is a set term. It can be transformed into $\neg C$: For every interpretation $\mathcal{I}$ of $S$ we have $(C^\neg)^\mathcal{I}=\mathcal{U}\backslash C^\mathcal{I}$ and $(\neg C)^\mathcal{I}=\Delta^\mathcal{I}\backslash C^\mathcal{I}$. Since $\mathcal{U}\subseteq \Delta$ we can conclude that every element in $(C^\neg)^\mathcal{I}$ is also in $(\neg C)^\mathcal{I}$.\\
The first five rules on the left hand side can be applied in linear time \cite{1},\cite{6}. The first four rules on the right hand side, $C^\neg\rightarrow \neg C$ and $\neg succ(c)\rightarrow succ(\neg c)$ can also be applied in linear time since we only shift the negation sign. the rule $(s^\neg)^\neg\rightarrow s$ works similarly to $\neg\neg C\rightarrow C$ and the rules $(s\cap t)^\neg\rightarrow s^\neg\cup t^\neg$ and $(s\cup t)^\neg\rightarrow s^\neg \cap t^\neg$ works the similarly to $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and can also be applied in linear time.\\
Next we introduce \textit{induced interpretation} with which we can count successors of variables after any rule application.
\begin{mydef}[Induced Interpretation]
An interpretation $\mathcal{I}(S)$ can be induced from an ABox $S$ by the following steps:
\begin{itemize}
\item for each variable $x\in Var(S)$ we introduce $x^{\mathcal{I}(S)}$ and add it to $\Delta^{\mathcal{I}(S)}$
\item for each $x:C$ such that $C$ is a concept name we add $x^{\mathcal{I}(S)}$ to $C^{\mathcal{I}(S)}$
\item for each $(x,y):r$ such that $r$ is a role name we add $(x^{\mathcal{I}(S)},y^{\mathcal{I}(S)})$ to $r^{\mathcal{I}(S)}$
\end{itemize}
\end{mydef}
Since we can now denote the number of successor of a variable $x$ we can determine which assertion of the form $x:succ(c)$ are violated.
\begin{mydef}[Violated assertion]
Let $S$ be a set of assertion, $x$ be a variable, $k$ be a cardinality term and $n\in\mathbb{N}$. An assertion is \textit{violated} if
\begin{itemize}
\item $x:succ(n\leq l)$ and $n\not\leq l^{\mathcal{I}(S)_x}$
\item $x:succ(k\leq n)$ and $k^{\mathcal{I}(S)_x}\not\leq n$
\item $x:succ(k\leq l)$ and $k^{\mathcal{I}(S)_x}\not\leq l^{\mathcal{I}(S)_x}$
\item $x:succ(n\,dvd\,k)$ and $mod(k^{\mathcal{I}(S)_x},n)\neq 0$
\end{itemize} 
where $n\in\mathbb{N}$.
\end{mydef}
Like already mentioned an ABox is unsatisfiable if all choices ends in a clash.
\begin{mydef}[Clash]
An ABox $S$ contains a \textit{clash} if
\begin{itemize}
\item $\{x:\perp\}\subseteq S$ or
\item $\{x:A,\,x:\neg A\}\subseteq S$ or
\item $\{x:succ(n\,\neg dvd\,l),x:succ(m\,dvd\,l)\}\subseteq S$, with $n\,dvd\,m$ or $m\,dvd\,n$, or
\item $\{(x,y):r,\,(x,y):r^\neg\}\subseteq S$ or
\item $\{x:succ(c)\}\subseteq S$ violated and no more rules are applicable
\end{itemize}
\end{mydef}
\iffalse
\subsection{The form of the ABox}
Like already mention a ABox $S$ in $\mathcal{ALCSCC}$ contains assertions of the form $x:C$ and $(x,y):C$ where $C$ is a $\mathcal{ALCSCC}$ concept and $x,y\in Var(S)$ are variables. Like already discussed we want constraints to be in $NNF$ and for an assertion $x:succ(c)$ that $c$ is either $k\leq l$ or $n\,dvd\,l$.
Our desired form for the ABox is gained by the following algorithm.
\begin{algorithm}[H] \caption{Transforming ABox}
\begin{algorithmic}[l]
\State ABox $S$
\ForEach {assertion $x:succ(c)\in S$}
\If {$c$ is $s_1\subseteq s_2$}
\State $c:=|s_1\cap s_2^\neg|\leq 0$; return;
\EndIf
\If{$c$ is $s_1\supseteq s_2$ and a set term constraint}
\State $c:=|s_1^\neg\cap s_2|\leq 0$; return;
\EndIf
\If{$c$ is $s_1=s_2$}
\State remove $x:succ(c)$;
\State add $x:succ(|s_1\cap s_2^\neg|\leq 0)$ and $x:succ(|s_1^\neg\cap s_2|\leq 0)$; return;
\EndIf
\If{$c$ is $l>k$}
\State $c:=k +1\leq l$; return;
\EndIf
\If{$c$ is $k<l$}
\State $c:=k +1\leq l$; return;
\EndIf
\If{$c$ is $l\geq k$}
\State $c:=k\leq l$; return;
\EndIf
\If{$c$ is $l=k$ and a cardinality constraint}
\State remove $x:succ(c)$;
\State add $x:succ(l\leq k)$ and $x:succ(k\leq l)$; return;
\EndIf
\EndFor\\
\ForEach{assertion $x:C$ or $(x,y):s$}
\State $C:=NNF(C)$ or $s:=NNF(s)$;
\EndFor
\end{algorithmic}
\end{algorithm}
The first part of the transformation runs in worst case in polynomial time: If any of the first four conditions holds, we only replace $c$ which runs in constant time.  The complexity of a removing function depends on the implementation: If we have direct access to the elements in the ABox the remove function has a constant (runtime) complexity. If we have some kind of sorting then the (runtime) complexity is logarithm. In worst case if we the ABox is stored as a simple list, then the (runtime) complexity is linear. Hence in worse cast the first part runs in polynomial time. The second part always runs in polynomial time because each transformation into $NNF$ runs in linear time. Hence our desired form of the ABox can be obtained in a polynomial time.
\fi
\subsection{Transforming an ABox into a formula}
Dealing with numerical arithmetic is challenging and hence we use the help of a $QFBAPA$ s. We want to use it whenever we want to add successors for a variable $x$. For that we collect all $succ$-assertion regarding $x$ first and then transform them into a $QFBAPA$ formula for one \textit{nested level}. As example we look at
\begin{ex}[Example for transforming ABox into $QFBAPA$ formula]
\begin{align*}
S=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|), x:succ(|A|\leq |B|), x:C\}
\end{align*}
\end{ex}
with $\mathbf{C}=\{A,B,C\}$ and $\mathbf{R}=\{r\}$
We first gather all $succ$-assertion regarding $x$ together and transform it into a formula by doing the following steps:
\begin{itemize}
\item drop all $x:succ$
\item replace all role names $r$ with $X_r$
\item replace all concepts names $C$ with $X_C$
\item replace all $succ(c)$ with $X_{c}$
\item connect all formulas with $\wedge$
\item include the conjunct $\mathcal{U}=X_{r_1}\cup\dots\cup X_{r_n}$, $r_1,\dots, r_n\in\mathbf{R}$
\end{itemize}
We replace (possible compound) concepts and role names with set variables, for which a solver can assign elements to them. We only replace concepts on one \textit{nested level}. In the example the first assertion tells that $x$ must have at least one successor $y$ which has more successors in $B\cap r$ than in $A$. The concept $succ(|A|\leq|B\cap r|)$ is on a different \textit{nested level} then $succ(|A|\leq |B|)$. The next step would be to introduce variables and the assignments according to the solution the solver gives us. Hence we also introduced variables for the nested $succ$-assertion. Then we can do the procedure from above again for the new variables.\\
\subsection{Algorithm}
Finally we can present the Tableau-algorithm for an ABox in $\mathcal{ALCSCC}$. We describe above how we handle the numeric arithmetic of $\mathcal{ALCSCC}$ and that we want to decompose compound concept first. Hence we divide the algorithm in two parts: a boolean part, where the decomposing of compound concepts takes place, and a numerical part, where a part of the ABox is transformed into a $QFBAPA$ formula and a solver returns a possible assignment of elements. The boolean part has a higher priority than the numerical part.
\begin{mydef}[Tableau]
Let $S$ be a set of assertions in simplified $NNF$.\\
Boolean part:
\begin{itemize}
\item\label{cap} $\sqcap$-rule: $S$ contains $x:C_1\sqcap C_2$ but not both $x:C_1$ and $x:C_2$\\
$\rightarrow$ $S:=S\cup\{x:C_1, x:C_2\}$
\item\label{cup} $\sqcup$-rule: $S$ contains $x:C_1\sqcup C_2$ but neither $x:C_1$ nor $x:C_2$\\
$\rightarrow$ $S:=S\cup\{x:C_1\}$ or $S:=S\cup\{x:C_2\}$
\end{itemize}
Numerical part:
\begin{itemize}
\item\label{succ} $successor$-rule: $S$ contains for an unmarked variable $x$ at least one assertion of the form $x:succ(c)$:
\begin{itemize}
\item gather all assertion of the form $x:succ(c)$ into a set $\mathcal{A}$
\item transform $\mathcal{A}$ into a $QFBAPA$ formula
\end{itemize}
If a $QFBAPA$ solver returns \textit{unsatisfiable} then $S=S\cup\{x:\perp\}$\\
If a $QFBAPA$ solver returns \textit{satisfiable} then
for each new element $e$ in the solution we introduce a new variable $y$ and
\begin{itemize}
\item for each $e\in X_C$ we have $S=S\cup\{y:C\}$
\item for each $e\in X_{c}$, $c$ is a cardinality constraint, we have $S=S\cup\{y:succ(c)\}$
\item for each $e\in X_r$, $r\in\mathbf{R}$, we have $S=S\cup\{(x,y):r\}$
\item mark $x$
\end{itemize}
and for each old element $e$ we add the remaining assertion according to above to $S$
\end{itemize}
\end{mydef}
We pick up Example 1 again but in a form where it is not decomposed yet:
\begin{align*}
S=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|)\sqcap succ(|A|\leq |B|)\sqcap C, (x,y):B\cap r\}
\end{align*}
We are able to apply the boolean rules and hence we apply them first and decompose into Example 1. Then we apply the $successor$-rule: We collect every $succ$-assertion regarding $x$ to a set $\mathcal{A}:=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|), x:succ(|A|\leq |B|)\}$ and convert $\mathcal{A}$ to the $QFBAPA$ formula $1\leq X_{|A|\leq|B\cap r|}\wedge|X_A|\leq |X_B|\wedge \mathcal{U}=\{X_r\}$. Then we let a solver returns an assignment if possible. In this case we see that the formula is satisfiable with $X_{|A|\leq|B\cap r|}=\{f\},X_A=\{\},X_B=\{e\}$ and $X_r=\{e,f\}$. Since we have $\mathcal{U}=\{X_r\}$ every element must be in $X_r$. That means that every successor is connected to its predecessor by a role name and in our example every successor is a $r$-successor. We then introduce for $e$ ans $f$ two variables $y$ and $z$ and the assertion $y:X_B$, $(x,y):r$, $z:succ(|A|\leq|B\cap r|)$ and $(x,z):r$ to $S$. Then for $z$ we have to apply the $successor$-rule again.
\section{Correctness}
For the correctness proof of the Tableau-algorithm we have to show that
\begin{itemize}
\item For every input the Tableau-algorithm terminates
\item If no more rules are applicable on a clash-free ABox $S$ then $S$ is satisfiable
\item If $S$ is satisfiable then the Tableau-algorithm terminates without a clash
\end{itemize}
First we prove that the tableau algorithm terminates. 
\begin{mypro}
Let $C$ be a concept in simplified $CNNF$. Then there is no infinite chain of applications of any tableau rules issuing from $\{x:C\}$. 
\end{mypro}
\begin{mydef}[Derived Set]
A \textit{derived set} is an ABox $S^\prime$ where rule \ref{repeat} is not applicable.
\end{mydef}
In order words a derived set is an ABox on which we applied a rule completely e.g. every time we add a new assertion $(x,y):s$ we add all assertion concluded by it to $S$ (rule \ref{repeat}) first.\\
To prove this we map any derived set $S$ to an element $\Psi(S)$ from a set $Q$. We then show that the elements in $Q$ can be ordered by a well-founded relation $\prec$. A well-founded relation says that there is no infinite decreasing chain. If we can show that by obtaining a derived set $S^\prime$ from another set $S$ we have $\Psi(S^\prime)\prec\Psi(S)$ then the algorithm terminates.\\
The elements in $Q$ are finite multisets of septuples and the elements of the septuples are either integers or mutlisets of integers. For two septuples $q=(q_1,\dots,q_7)$ and $q^\prime=(q^\prime_1,\dots,q^\prime_7)$ it holds $q\prec q^\prime$ if for the first $i,\, 1\leq i\leq 7$, for which $q_i$ and $q_i^\prime$ differs it holds that $q_i\prec q_i^\prime$ (also called lexicographical ordering). For two mutlisets of integers $q_i$ and $q_i^\prime$ it holds $q_i^\prime\prec q_i$ if $q_i^\prime$ can be obtained from $q_i$ by replacing an integer $c$ in $q_i^\prime$ by a finite number of integers which are all smaller than $c$. The relation $\prec$ for those multisets is well-founded because we work with integers. That means from a multiset $\{0,\,\dots\,,0\}$ the smallest multiset which can be obtain is $\{\}$ by removing all $0$s.\\
For a concept $C$ its size $size(C)$ is inductively defined as
\begin{itemize}
\item $0$, if $C$ is $\perp$
\item $1$, if $C$ is a concept name of $\mathbf{C}$
\item $size(\neg C)= 1+size(C)$
\item $size(succ(c))= 1 + \sum_{C\text{ in c}} size(C)$
\item $size(C\sqcap D)=size(C\sqcup D)=size(C)+size(D)$
\end{itemize}
The asymmetrical difference of two numbers $n,m$ is denoted by 
\begin{equation*}
n\unlhd m \begin{cases}
n-m& \text{if } n> m\\
0 & \text{if } n\leq m
\end{cases}
\end{equation*}
The septuples in $Q$ are defined as follows
\begin{mydef}
Let $S$ be an ABox. The multiset $\Psi(S)$ consist of septuples $\psi_S(x)$ for each variable $x$. The component of the septuples are structured as follows
\begin{itemize}
\item the first component is a non-negative integer $max\{size(C)\mid x:C\in S\}$
\item the second component is a multiset of integers containing for each $x:C\sqcap D$, on which the $\sqcap$-rule is applicable, the non-negative integer $size(C\sqcap D)$ (respectively for $C\sqcup D$)
\item the third component is the number of $x$'s successors on which rule \ref{chooserole} is applicable
\item the fourth component is a multiset of integers containing for each $x:succ(k\leq n)\in S$ the number of all successors $y$ of $x$ on which rule \ref{choose} is applicable
\item the fifth component is a multiset which denotes for every $x:succ(k\leq l)$ and $x:succ(n\,dvd\,l)$ the integer $k^{\mathcal{I}(S)_x}\unlhd l^{\mathcal{I}(S)_x}$ and $n\unlhd l^{\mathcal{I}(S)_x}$ respectively
\item the sixth component denotes the number of all successors of $x$.
\item the seventh component is a multiset which denotes for each $x:succ(k\leq 0)$ the number of successors on which the rule \ref{leq} is applicable
\end{itemize}
\end{mydef}
\begin{mylem}
The following properties hold
\begin{enumerate}
\item For any concept $C$ we have $size(C)\geq size(NNF(\neg C))$
 \item Any variable $y$ in a derived set $S$ has at most one predecessor $x$ in $S$
\item If $(x,y):r\in S$ for a $r\in\mathbf{R}$ (and $y$ is a introduced variable) then 
\begin{align*}
max\{size(C)\mid x:C\in S\}>max\{size(D)\mid y:D \in S\}
\end{align*}
\end{enumerate}
\end{mylem}
\begin{proof}$ $\\
\vspace*{-5mm}
\begin{enumerate}
\item By induction over the number of applications to compute the negation normal form we have $size(C)=size(NNF(\neg C))$. Because $\neg succ(0\leq k)$ can be replace by $\perp$ which is $smaller$, we have $size(C)\geq size(NNF(\neg C))$. This can be done because $\neg succ(0\leq k)= succ(k<0)$ which is impossible to satisfy and therefore $\neg succ(0\leq k)=\perp$.
\item If $y$ is a newly introduced variable, then it can only be introduced by exactly one variable $x$ which is $y$'s only predecessor. If two variables are merged together by rule \ref{exceeded} then both variables must have the same predecessor $x$ by the condition of that rule.
\item By the second fact we know that $x$ is the only predecessor of $y$. When $y$ is introduced by applying \ref{leq} on a assertion $x:succ(k\leq l)$ then we have $y:C$ for every concept $C$ occurring in $l$ (for $\neg C$ we have $y:\neg C$). We know that $size(succ(k\leq l))$ is greater then $size(C)$ therefore Lemma 1.3 holds. A new assertion $y:D$ can occur either because rule \ref{cap} or \ref{cup} are applicable on $y:C$ with $C=D\sqcap D^\prime$ or $C=D\sqcup D^\prime$, which neither raise $max\{size(D)\mid y:D \in S\}$, or because rule \ref{choose} is applicable but that also does not raise $max\{size(D)\mid y:D \in S\}$: If rule \ref{choose} is applicable on $x:succ(k\leq l)$ then for every added assertion $y:D$ the concept $D$ must occur in $k$ and therefore $size(succ(k\leq l))>size(D)$. If $y$ gets merged together with another variable $z$, then $y$ and $z$ must have the same predecessor which means that all concept sizes regarding $z$ are also smaller then $max\{size(C)\mid x:C\in S\}$. 
\end{enumerate}
\end{proof}
\iffalse
From the next Lemma we can conclude that the Tableau-algorithm terminates.
\begin{mylem}
If $S^\prime$ is a derived set obtained from the derived set $S$, then $\Psi(S^\prime)\prec\Psi(S)$
\end{mylem}
\begin{proof}
The following proof is sectioned by the definition of obtaining a derived set.
\begin{enumerate}
\item $S^\prime$ is obtained by the application of rule \ref{cap} on $x:C\sqcap D$:\\
The first component remains the same because $size(C)<size(C\sqcap D)$ and $size(D)<size(C\sqcap D)$. The second component decreases because rule \ref{cap} can not be applied on $x:C\sqcap D$ any more meaning that the corresponding entry in the multiset is removed. If $C$ (or $D$) happens to be a disjunction ($C^\prime\sqcup D^\prime$) or a conjunction ($C^\prime\sqcap D^\prime$) then the second component also becomes smaller because $size(C^\prime)$ and $size(D^\prime)$ are always smaller than the disjunction or conjunction of them and therefore also smaller than $size(C\sqcap D)$. Hence the entry for $size(C\sqcap D)$ can be replace by the smaller $size(C^\prime\sqcup D^\prime)$ or $size(C^\prime\sqcap D^\prime)$.\\
Consider now a tuple $\psi_S(y)$ such that $x\neq y$. $\psi_S(y)$ can only be affected if $x$ is a successor of $y$. The first and second component of $\psi_S(y)$ remain unaffected because both are independent from $x$. The third and fourth component of can never in creases because we do not add any new successors. If at all the components can decreases because it may happen that by adding assertions regarding $x$ rule \ref{choose} (or rule \ref{chooserole}) can not be applied any more on some assertion $y:succ(k\leq l)$. The same goes for the fifth component: If there is an assertion $y:succ(k\leq l)$ and by adding $x:C$ and $x:D$ to $S$ neither $k^{\mathcal{I}(S^\prime)_y}$ nor $l^\mathcal{I}(S)_y$ change because by the definition of $\mathcal{I}(S)$ we have $x\in (C\sqcap D)^{\mathcal{I}(S)_y}=C^{\mathcal{I}(S)_y}\sqcap D^{\mathcal{I}(S)_y}\subseteq C^{\mathcal{I}(S)_y}$ and $\subseteq D^{\mathcal{I}(S)_y}$. This means that $x$ is not added to any further extension in $\mathcal{I}(S^\prime)$ and hence $k^{\mathcal{I}(S^\prime)_y}$ nor $l^{\mathcal{I}(S)_y}$ remain the same. The sixth component also do not change: From the beginning we have $x:C\sqcap D$, which means that if rule \ref{leq} is not applicable then it stays inapplicable after $x:C$ or $y:D$ is added. We can conclude that the tuple $\psi_S(y)$ remains in total unchanged or decreases.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$ and, if needed, $\psi_S(y)$ with a smaller tuple $\psi_{S^\prime}(y)$. 
\item $S^\prime$ is obtained by the application of rule \ref{cup} on $x:C\sqcup D$:\\
similar to above
\item $S^\prime$ is obtained by the application of rule \ref{choose} on $x:succ(k\leq l)$ for a successor $y$ and of rule \ref{repeat}:\\
The first and second component of $\psi_S(x)$ do not change because this step only adds assertion regarding $y$. The third component can not increase: If rule \ref{chooserole} is applicable then there is a change that by adding the new assertion $(x,y):k$ we also add $(x,y):r,r\in\mathbf{R}$ (by rule \ref{repeat}), which leads to the fact that rule \ref{chooserole} is not applicable any more and hence the tuple becomes smaller. The fourth component becomes smaller because rule \ref{choose} can not be applied any more on $y$ and hence the corresponding number in the multiset decreases which lead to a smaller tuple $\psi_{S^\prime}(x)$.\\
We consider now a tuple $\psi_S(z)$ such that $y\neq z$ and $x\neq z$. The tuple $\psi_S(z)$ can only be affected if $z$ is the predecessor of $y$. However by Lemma 1.2 a variable can only have one predecessor and hence $z$ must be $x$.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$. 
\item $S^\prime$ is obtained by the application of rule \ref{chooserole} on a successor $y$ and of rule \ref{repeat}:\\
The first two component remains unchanged. The third component always decreases because the number of $x$'s successor on which rule \ref{chooserole} is applicable decreases.\\
We consider now a tuple $\psi_S(z)$ such that $y\neq z$ and $x\neq z$. The tuple $\psi_S(z)$ can only be affected if $z$ is the predecessor of $y$. However by Lemma 1.2 a variable can only have one predecessor and hence $z$ must be $x$.\\
This means that we can obtain $\Psi(S^\prime)$ from $\Psi(S)$ by replacing $\psi_S(x)$ with the smaller tuple $\psi_{S^\prime}(x)$. 
\item $S^\prime$ is obtained by the application of rule \ref{dvd} on a assertion $x:succ(n\,dvd\,l)$ and of rule \ref{repeat}:\\
The first two components again remains unchanged. \textcolor{red}{lol}
\item $S^\prime$ is obtained by the application of rule \ref{exceeded} on an assertion $x:succ(k\leq l)$:\\
The first two components remains unchanged. The third and fourth component can only decrease because we have one less successor. Furthermore if rule \ref{choose} (or \ref{chooserole} is applicable on at least one of the two variables then by merging we can gain a new variable, on which the rule is inapplicable. Therefore those four component can not increase. The fifth component also can not increase: Since we can apply rule \ref{exceeded} on $x:succ(k\leq l)$ we know that this assertion is violated, hence $k^{\mathcal{I}(S)_x}>l^{\mathcal{I}(S)_x}$. By applying this rule \textcolor{red}{help}....
\end{enumerate}
\end{proof}
\begin{mylem}
If the Tableau-algorithm terminates without a clash then $S$ is satisfiable
\end{mylem}
\begin{proof}$ $\\
Again the proof is sectioned by the obtained derived sets.\\
Let $\mathcal{I}(S^\prime)$ be the induced interpretation of the ABox $S^\prime$ created by the Tableau-algorithm from $S$. We show that $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.\\
We start with the simple assertions $x:C$ and $(x,y):r$ for $C\in\mathbf{C}$ and $r\in\mathbf{R}$ (induction base): By the definition of induced interpretation we assign $\pi_{\mathcal{I}(S^\prime)}(x):=x^{\mathcal{I}(S^\prime)}\in C^{\mathcal{I}(S^\prime)}$. Also by the definition of induced interpretation for every $(x,y):r\in S^\prime$ we have $(\pi_{\mathcal{I}(S^\prime)}(x),\pi_{\mathcal{I}(S^\prime)}(y)):=(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})\in r^{\mathcal{I}(S^\prime)}$.\\
Let $S$ be an ABox and $\pi_{\mathcal{I}(S)}$ be an assignment which satisfies $S$ (induction hypothesis).
\begin{enumerate}
\item If we can apply rule \ref{cap} and obtain $S^\prime$ then there must be an assignment $x:C_1\sqcap C_2\in S$. By the definition of induced interpretation and by the hypothesis we already have $\pi_{\mathcal{I}(S^\prime)}(x)\in C_1^{\mathcal{I}(S^\prime)}$ and $\pi_{\mathcal{I}(S^\prime)}(x)\in C_2^{\mathcal{I}(S^\prime)}$. By adding $x:C_1$ and $x:C_2$ we do not change $\mathcal{I}(S)$. Hence $\mathcal{I}(S^\prime):=\mathcal{I}(S)$ and $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{cup} and obtain $S^\prime$ then there must be an assignment $x:C_1\sqcup C_2\in S$. Like above by the definition of the induced interpretation we have $\pi_{\mathcal{I}(S^\prime)}(x):=x^{\mathcal{I}(S^\prime)}$. We also know that $x^{\mathcal{I}(S^\prime)}$ is in $C_1^{\mathcal{I}(S^\prime)}\cup C_2^{\mathcal{I}(S^\prime)}$. By adding either $x:C_1$ or $x:C_2$ we do not change $\mathcal{I}(S)$. Hence $\mathcal{I}(S^\prime):=\mathcal{I}(S)$ and $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{choose} and obtain $S^\prime$ then we have an assertion $x:succ(k\leq l)$ and a successor $y$ such that $(x,y):k^\prime\in S$, $k^\prime$ occurs in $k$. We then choose between $(x,y):s$ and $(x,y):s^\neg$ for all $|s|$ in $k$ then apply rule \ref{repeat} until this rule is inapplicable. That means at the end we might add several assertions of the form $x:C$ and $(x,y):r$. In case we add $x:C$ we also add $x^{\mathcal{I}(S^\prime)}$ to $C^{\mathcal{I}(S^\prime)}$. Therefore in this case $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$. In case we add $(x,y):r$ we also add $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ to $r^{\mathcal{I}(S^\prime)}$. Hence $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{chooserole} and obtain $S^\prime$ then we have an assertion $(x,y):k$ but for every role name $r$ we do not have $(x,y):r\in S$, where $r$ has a positive sign in this assertion. After adding $(x,y):r$, $r\in\mathbf{R}$, to $S^\prime$ the element $(x^{\mathcal{I}(S)},y^{\mathcal{I}(S)})$ is also added to $r^{\mathcal{I}(S^\prime)}$. Hence $\pi_{\mathcal{I}(S^\prime)}$ satisfies $S^\prime$.
\item If we can apply rule \ref{leq} and obtain $S^\prime$ then we have an assertion $x:succ(c)$ such that it is violated regarding $x$.\\
We introduce $y$ and add $(x,y):l$ to $S$ and then apply rule \ref{repeat} until this rule is inapplicable. When we introduce $y$ we also add a new element $y^{\mathcal{I}(S^\prime)}$ to $\mathcal{I}(S^\prime)$. For each $y:C$ we add $y^{\mathcal{I}(S^\prime)}$ to $C^{\mathcal{I}(S^\prime)}$ and for each $(x,y):r$, $r\in\mathbf{R}$, we add $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ to $r^{\mathcal{I}(S^\prime)}$. Therefore let $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}\cup \{y\mapsto y^{\mathcal{I}(S^\prime)}\}$.
\item If we can apply rule \ref{leq} and obtain $S^\prime$ then we have an assertion $x:succ(k<l)$ or $x:succ(k\leq l)$ such that it is violated regarding $x$. We also have two successors $y_1$ and $y_2$ for which $(x,y):s$ and $(x,y):s$ are in $S$.\\
If we merge both together to $y$ we also have to merge $y_1^{\mathcal{I}(S)}$ and $y_2^{\mathcal{I}(S)}$ to one element $y^{\mathcal{I}(S^\prime)}$. For each $y_i:C\in S$, $i\in\{1,2\}$ we have $y_i^{\mathcal{I}(S)}\in C^{\mathcal{I}(S)}$ and for each $(x,y_i):r$, $r\in\mathbf{R}$ we have $(x^{\mathcal{I}_S},y_i^{\mathcal{I}(S)})\in r^{\mathcal{I}(S)}$ due to the hypothesis. That means that by merging both elements the element $y^{\mathcal{I}(S^\prime)}$ must be in $C^{\mathcal{I}(S^\prime)}$ for every $y_i^{\mathcal{I}(S)}\in C^{\mathcal{I}(S)}$ and the element $(x^{\mathcal{I}(S^\prime)},y^{\mathcal{I}(S^\prime)})$ must be in $r^{\mathcal{I}(S^\prime)}$ for every $(x^{\mathcal{I}(S)},y_i^{\mathcal{I}(S)})\in r^{\mathcal{I}(S)}$. Therefore let $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}\backslash\{y_1\mapsto y_1^{\mathcal{I}(S)}, y_2\mapsto y_2^{\mathcal{I}(S)}\}\cup\{y\mapsto y^{\mathcal{I}(S)}\}$ which satisfies $S^\prime$.
\item If we can apply rule \ref{s} and obtain $S^\prime$ then we have an assertion $x:succ(c_1\subseteq c_2)$ and a successor $y$ such that $(x,y):c_1\in S$ but $(x,y):c_2\notin S$. By adding $(x,y):c_2$ to $S$ we have also to add $y:C$ for every concept $C$ in $c_2$ and $(x,y):r$ for every role name $r$ in $c_2$. That means that $x^{\mathcal{I}(S)}$ is added to every $C^{\mathcal{I}(S)}$ and that $(x^{\mathcal{I}(S)},x^{\mathcal{I}(S)})$ is added to every $r^{\mathcal{I}(S)}$. Therefore the assignment $\pi_{\mathcal{I}(S^\prime)}:=\pi_{\mathcal{I}(S)}$ satisfies $S^\prime$.
\end{enumerate}
\end{proof}
\begin{mylem}
If $S$ is satisfiable then the Tableau-algorithm terminates without a clash.
\end{mylem}
\begin{proof}
\end{proof}
\fi
\normalem
\bibliographystyle{abbrv}
\bibliography{ref}
\end{document}
