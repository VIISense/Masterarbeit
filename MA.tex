\documentclass[a4paper,11pt]{scrartcl}
\usepackage[english]{babel}  % falls der Artikel auf Deutsch verfasst ist
% Verwenden Sie nur EINE der beiden folgenden Zeilen, je nachdem, ob Ihr
% Betriebssystem LATIN1 (=ISO-8859-1) oder UTF8 als Zeichenkodierung
% verwendet. Ob Sie die richtige verwenden, merken Sie daran, dass
% die Umlaute richtig im Dokument dargestellt werden.
\usepackage[utf8]{inputenc}
\usepackage{amsmath}
\usepackage{ulem}
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{stmaryrd}
\usepackage{dsfont}
\usepackage{float}
\newtheoremstyle{break}
  {\topsep}{\topsep}%
  {\itshape}{}%
  {\bfseries}{}%
  {\newline}{}%
\theoremstyle{break}
\theoremstyle{definition}
\newtheorem{mydef}{Definition}
\newtheorem{mylem}{Lemma}
\newtheorem{mythe}{Theorem}
\newtheorem{mycol}{Corollary}
\newtheorem{mypro}{Proposition}
\newtheorem{ex}{Example}
\usepackage{color}
\usepackage{paralist}
\usepackage{tikz}
\usetikzlibrary{shapes,snakes,arrows}
\usepackage{verbatim}
\usetikzlibrary{positioning}
\usepackage{algpseudocode}
\usepackage{algorithm}
\usepackage{pgfplots}
\pgfplotsset{compat=1.8}
\usetikzlibrary{patterns}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\usepackage{ulem}
\newcommand{\RM}[1]{\MakeUppercase{\romannumeral #1{}}}
\usepackage{url}
\makeatletter
\newcommand{\oset}[3][0ex]{%
  \mathrel{\mathop{#3}\limits^{
    \vbox to#1{\kern-2\ex@
    \hbox{$\scriptstyle#2$}\vss}}}}
\makeatother
\pgfplotsset{
    standard/.style={
        axis x line=middle,
        axis y line=middle,
        enlarge x limits=0.1,
        enlarge y limits=0.15,
        every axis x label/.style={at={(current axis.right of origin)},anchor= north west},
        every axis y label/.style={at={(current axis.above origin)},anchor= east}
    }
}
\begin{document}
\tableofcontents
\newpage
\section{Introduction}
Traditional data bases where data are stored solely without any connection towards to themselves like many people would imagine are often not enough any more. The reason is that the data are stored without any semantics. However storing data with semantics can provide additional information. For example we have some data about two objects \textit{"Anna"} and \textit{"Beth"}. In a traditional data base, if not explicitly stated, both data are not related to each other. Nethertheless Anna and Beth can have a relation, which also depends on who or what both are. For example both can be human and Anna is a teacher and Beth is a student and are assigned to the same class. By adding solely those information in a traditional data base the information that Anna must teache Beth is not given. One way to apply semantics to data objects is to use \textit{ontologies}. In biological and (bio)medical researches data bases are often based on ontologies \cite{bio}. Ontologies (in the computer science field) can be viewed as formal representation of a certain domain of interest. In data base they are collection of relations between the entities in the data base and are formulated as a fragment of first-order logic (FOL). These fragments of FOL are represented as \textit{Description Logic (DL)}, which is a family of knowledge representation system. DLs are mainly built of concepts, which correspond to unary relations in FOL and is often represented by a capital letter, and relation between the concepts, which correspond to binary relations in FOL and is often represented by a lowercase letter. For more complex (compound) concepts operators like $\sqcap$, $\sqcup$,$\sqsubseteq$, $\exists$ and $\forall$, depending on the DL, are used. For example the statement "All Men and Women are Human" is formalized in FOL as $\forall x.Men(x)\vee Women(x)\rightarrow Human(x)$ and in DL as an \textit{axiom} $Men\,\sqcup\, Women\sqsubseteq Human$, where $Men$,$Women$ and $Human$ are concept names. The statement "All Humans, who have children, are parents" can be formalized in FOL as $\forall x \exists y. Human(x)\wedge hasChildren(x,y)\rightarrow Parent(x)$ and in DL as $Human\sqcap \exists hasChildren.\top \sqsubseteq Parent$, where $Human$ and $Parents$ are concept names and $hasChildren$ is a role name. Restriction with the operators $\exists$ and $\forall$ are called \textit{quantified} restrictions. The second statement can also be formalized with a \textit{qualified} restriction: $Human\sqcap \geq 1 hasChildren.\top\sqsubseteq Parent$. Each quantified restriction can be transformed into a qualified restriction.\\
A knowledge base consists of a \textit{TBox}, which contains the axioms (rules), and of an \textit{ABox} which contains assertions of certain elements (objects). One big research field in DL is the determination of satisfiability of a \textit{knowledge base}, which is formulated in DL.  In \cite{1} a \textit{Tableau}-algorithm is presented for checking satisfiability for an ABox in the DL $\mathcal{ALCQ}$. This DL allows conjunctions ($\sqcap$), disjunctions ($\sqcup$), negation $\neg C$ and qualifying number restriction ($\leq\,n\,r\, C$ and $\geq \, n\, r\, C$), where $n$ is a number, $r$ a role name, and $C$ a concept name. A Tableau-algorithm applies \textit{completion rules} to a given \textit{set}(ABox) to decompose complex concepts and try satisfiying violated assertions. The satisfiability (of concepts) is stated in \cite{1} as PSPACE-hard problem (without TBox, with TBox it is EXPTime-hard \cite{4}). In \cite{pspace} a optimized Tableau-algorithm is presented which states that it is a PSPACE-problem. The optimization is that instead of keeping $n$ successors to satisfy a restriction $\geq\,n\,r.C$ like in \cite{1}, the algorithm saves the number of existing successors and by comparing the numbers detects possible \textit{clashes}.\\
The expressive DL $\mathcal{ALCSCC}$ extends $\mathcal{ALCQ}$ with \textit{set constraint} and \textit{cardinality constrant}, which lays under the logic of \textit{QFBAPA} (quantifier-free fragment of Boolean Algebra with Presburger Arithmetic). As the name says we do not have quantifier. Instead we use set expression (Boolean Algebra part) and numerical constraint (Presburger Arithmetic) which is combined together with cardinality functions. For example $Human\sqcap \geq 1\,hasChildren.\top\sqsubseteq Parent$ is written in $\mathcal{ALCSCC}$ as $Human\sqcap succ(|hasChildren|\geq 1)\sqsubseteq Parent$. This DL is more expressive than $\mathcal{ALCQ}$ because every qualified restriction $\leq\,n\,r.C$ and $\geq \, n\, r.C$ can be written in $\mathcal{ALCSCC}$ as $succ(|r.C|\leq 1)$ and $succ(|r.C|\geq 1)$. In \cite{4} a solution for the satisfiability problem (without TBox) is presented which has the complexity PSpace: For an ABox we guess the value (true or false) of the top-level variables which can already lead to a \textit{false}-result. If not then the constraint is formulated into a $QFBAPA$ formula, for which an algorithm determine by guessing a number $N$ of Venn-region to be non-empty whether the formula is satisfied or not.\\
In this work we present a Tableau-algorithm for $\mathcal{ALCSCC}$. As in previous work for other DLs we define completion rules which can be applied onto assertions in the ABox to determine whether $\perp$ can be concluded from it which states its unsatisfiability. If we can not apply any rules any more and we can not conclude $\perp$, then the ABox is satisfiable. The main difficulty is that unlike $\mathcal{ALCQ}$, where the bond of number of successor is fixed, in $\mathcal{ALCSCC}$ we can compare two cardinalities, which can vary during the algorithm. Hence we need an approach for counting successors and with it calculating the \textit{correct} cardinality, which is necessary to detect satisfied and violated constraint. For this we introduce \textit{induced interpretation} which can determine the cardinalities after each rule application. Further more to deal with the numerical arithmetic of $\mathcal{ALCSCC}$ we use a $QFBAPA$ solver, of which we assume it is capable to return all possible solution. We transform a subset of the ABox into a $QFBAPA$ formula and then let a solver determine whether the formula is satisfiable or not. If not we end with a clash. If it returns a solution, then we add variables according to it to our ABox. To ensure that the algorithm terminates we show that we are able to bound the number of finite solution.
\section{Preliminaries}
Before we define the DL $\mathcal{ALCSCC}$ we have to explain first how the language $QFBAPA$ looks like. It combines boolean algebra (BA) of sets of symbols with Presburger arithmetic (PA):
\begin{mydef}[$QFBAPA$]
Let $T$ be a set of symbols
\begin{itemize}
\item set terms over $T$ are:
\begin{itemize}
\item empty set $\emptyset$ and universal set $
\mathcal{U}$
\item every set symbol in $T$
\item if $s,t$ are set terms then also $s\cap t$, $s\cup t$ and $s^{\neg}$
\end{itemize}
\item set constraints over $T$ are
\begin{itemize}
\item $s\subseteq t$ and $s\not\subseteq t$
\item $s=t$ and $s\neq t$
\end{itemize}
where $s,t$ are set terms
\item cardinality terms over $T$ are:
\begin{itemize}
\item every number $n\in \mathbb{N}$
\item $|s|$ if $s$ is a set term
\item if $k,l$ are cardinality terms then also $k+l$ and $n\cdot k$, $n\in \mathbb{N}$
\end{itemize}
\item cardinality constraints over $T$ are:
\begin{itemize}
\item $k=l$ and $k\neq l$
\item $k<l$ and $k\geq l$
\item $k\leq l$ and $k>l$
\item $n$ $dvd$ $k$ and $n$ $\neg dvd$ $k$
\end{itemize}
where $k,l$ are cardinality terms and $n\in\mathbb{N}$
\end{itemize}
A $QFBABA$ formula $\phi$ is a disjunction ($\vee$) and conjunction ($\wedge$) of (also possible negated) cardinality constraints, where every set symbol is represented as a set variable.
\end{mydef}
Since $s\subseteq t$ can be expressed as the cardinality constraint $|s\cap t^\neg|\leq 0$ we will not consider any set constraints further in this work. In case we want to express $x:succ(s=t)$, with $s,t$ being set terms, we write instead $x:succ(|s\cap t^\neg|\leq 0)\sqcap succ(|s^\neg\cap t|\leq 0)$. Furthermore instead of $l\geq k$ we write $k\leq l$, instead of $k<l$ we write $k+1\leq l$ and instead of $k=l$ we write $k\leq l$ and $l\leq k$. Hence for an assertion $x:succ(c)$ the cardinality constraint $c$ is either of the form $k\leq l$ or $n\,dvd\,l$.\\
The semantic of $QFBAPA$ is define as follows:
\begin{mydef}[Interpretation of $QFBAPA$]
Let $\Delta^\mathcal{I}$ be a set and $\sigma$ a mapping which maps
\begin{itemize}
\item every symbol $a$ in $T$ to $\sigma(a)$
\item $\emptyset$ to $\sigma(\emptyset)$
\item $\mathcal{U}$ to $\sigma(\mathcal{U})\subseteq \Delta^\mathcal{I}$
\item $\sigma(s\cap t):= \sigma(s)\cap \sigma(t)$, $\sigma(s\cup t):= \sigma(s)\cup \sigma(t)$
\item $\sigma(s^\neg):=\sigma(\mathcal{U})\backslash \sigma(s)$
\item $\sigma(|s|):=|\sigma(s)|$
\item $\sigma(k+l):=\sigma(k)+\sigma(l)$, $\sigma(n\cdot k):= n\cdot \sigma(k)$
\end{itemize}
The mappings satisfies for the cardinality terms $k,l$
\begin{itemize}
\item $k\leq l$ iff $\sigma(k)\leq \sigma(l)$
\item $n\,dvd\,l$ iff $\exists m\in\mathbb{N}:n\cdot m = \sigma(l)$
\end{itemize}
\end{mydef}
The mapping $\sigma$ is a solution of a $QFBAPA$ formula $\phi$ if it satisfies all cardinality constraints in $\phi$.\\
Let $\mathbf{C}$ be a set of concept names and $\mathbf{R}$ a set of role names, such that $\mathbf{C}$ and $\mathbf{R}$ are disjoint.
\begin{mydef}[$\mathcal{ALCSCC}$]
$\mathcal{ALCSCC}$ concepts are defined inductively:
\begin{itemize}
\item all concept names
\item if $C,D$ are concepts then:
\begin{itemize}
\item $\neg C$
\item $C\sqcup D$
\item $C\sqcap D$
\end{itemize}
\item $succ(c)$ if $c$ is a cardinality constraint over $\mathcal{ALCSCC}$ concepts and role names
\end{itemize}
\end{mydef}
An ABox $\mathcal{A}$ in $\mathcal{ALCSCC}$ is a finite set of assertions of the form $x:C$ and $(x,y):r$, where $C$ is a $\mathcal{ALCSCC}$ concept, $r\in\mathbf{R}$ and $x,y$ are variables. The set $Var(\mathcal{A})$ is the set of variables occurring in $\mathcal{A}$. 
\begin{mydef}[Interpretation]
An \textit{interpretation} $\mathcal{I}=(\Delta^\mathcal{I},\cdot^\mathcal{I})$ over an ABox $\mathcal{A}$ in $\mathcal{ALCSCC}$ consists of a non-empty set $\Delta^\mathcal{I}$ and a mapping $\cdot^\mathcal{I}$ which maps:
\begin{itemize}
\item each variable $x\in Var(\mathcal{A})$ to $x^\mathcal{I}\in \Delta^\mathcal{I}$
\item every concept names $A\in\mathbf{C}$ to $A^\mathcal{I}\subseteq \Delta^\mathcal{I}$
\item every role name $r\in\mathbf{R}$ to $r^\mathcal{I}\subseteq\Delta^\mathcal{I}\times\Delta^\mathcal{I}$, such that every element in $\Delta^\mathcal{I}$ has a finite number of successors.
\end{itemize}
The set $r^\mathcal{I}(x)$ contains all elements $y$ such that $(x,y)\in r^\mathcal{I}$ e.g. it contains all $r$-successors of $x$.\\
For compound concepts the mapping $\cdot^\mathcal{I}$ is extended inductively as follows
\begin{itemize}
\item $\top^\mathcal{I}=\Delta^\mathcal{I}$ and $\perp^\mathcal{I}=\emptyset^\mathcal{I}$
\item $(C\sqcap D)^\mathcal{I}:=C^\mathcal{I}\cap D^\mathcal{I}$, $(C\sqcup D)^\mathcal{I}:=C^\mathcal{I}\cup D^\mathcal{I}$
\item $(\neg C)^\mathcal{I}:=\Delta^\mathcal{I}\backslash C^\mathcal{I}$
\item $succ(c)^\mathcal{I}=\{x\in \Delta^\mathcal{I}|$the mapping $\cdot^{\mathcal{I}_x}$ satisfies $c\}$
\end{itemize}
The mapping $\cdot^{\mathcal{I}_x}$ maps $\emptyset$ to $\emptyset^\mathcal{I}$, $\mathcal{U}$ to $\mathcal{U}^{\mathcal{I}_x}:=\{\bigcup_{r\in\mathbf{R}}r^\mathcal{I}(x)\}$, every concept $C$ occurring in $c$ to $C^{\mathcal{I}_x}:=C^\mathcal{I}\cap \mathcal{U}^{\mathcal{I}_x}$ and every role name $r$ occurring in $c$ to $r^{\mathcal{I}_x}:=r^\mathcal{I}(x)$.\\
$\mathcal{I}$ is a model of $\mathcal{A}$ iff
\begin{itemize}
\item $x:C$ iff $x^\mathcal{I}\in C^\mathcal{I}$ 
\item $(x,y):r$ iff $(x^\mathcal{I},y^\mathcal{I})\in r^\mathcal{I}$
\end{itemize} 
\end{mydef}
Note that in a concept $succ(c)$ $c$ can also be a cardinality constraint over $A\sqcap B$ and $A\sqcup B$. Since the semantic of $A\sqcap B$ and $A\cap B$ (analogously for $A\sqcup B$ and $A\cup B$) are defined the same way ($(C\sqcap D)^\mathcal{I}=C^\mathcal{I}\cap D^\mathcal{I}$ and $\sigma(C\cap D)=\sigma(C)\cap\sigma(D)$), we make the assumption that every $\sqcap$ and $\sqcup$ within a $succ(c)$ concept are replaced with $\cap$ and $\cup$.
\section{Tableau for $\mathcal{ALCSCC}$}
A Tableau-algorithm consists of completion rules to decide satisfiability of a set of assertions. The rules are applied exhaustively on the set until none is applicable any more. One major characteristic of this algorithm is that it does not matter in which order the rules are applied. Another characteristic is that it works non-deterministically: In case we have disjunctions we can choose between the concepts in this disjunction. If a choice ends in a \textit{clash} then we track back to the point where we had to chose and take the other choice instead. If all choices end in a clash then the ABox is unsatisfiable, otherwise it is satisfiable.\\
We want to use the Tableau-algorithm to check whether an assertion $x:C$ is satisfiable or not and if it satisfiable then we create a satisfied ABox from $x:C$.\\
To help the algorithm we want to avoid nested negation e.g. $\neg(\neg(\neg(A\cup B)))$. Hence we consider all concepts in \textit{negated normal form (NNF)}.
\begin{mydef}[Negation Normal Form]
A $\mathcal{ALCSCC}$ concept is in \textit{negation normal form} ($NNF$) if the negation sign $\neg$ appears only in front of a concept name or above a role name. Let $C$ be a arbitrary $\mathcal{ALCSCC}$ concept. With $NNF(C)$ we denote the concept which is obtained by applying the rules below on $C$ until none is applicable any more.
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $\neg\top$ $\rightarrow$ $\perp$
\item $\neg\perp$ $\rightarrow$ $\top$
\item $\neg\neg C$ $\rightarrow$ $C$
\item $\neg(C\sqcap D)$ $\rightarrow$ $\neg C \sqcup \neg D$
\item $\neg(C\sqcup D)$ $\rightarrow$ $\neg C \sqcap \neg D$
\item $C^\neg$ $\rightarrow$ $\neg C$
\item $\neg succ(c)$ $\rightarrow$ $succ(\neg c)$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $\neg (k\leq l)$ $\rightarrow$ $l\leq k$
\item $\neg (n\text{ } dvd \text{ } k)$ $\rightarrow$ $n\text{ } \neg dvd \text{ } k$
\item $\neg (n\text{ } \neg dvd \text{ } k)$ $\rightarrow$ $n\text{ } dvd \text{ } k$
\item $(s\cap t)^\neg$ $\rightarrow$ $s^\neg \cup t^\neg$
\item $(s\cup t)^\neg$ $\rightarrow$ $s^\neg \cap t^\neg$
\item $(s^\neg)^\neg$ $\rightarrow$ $s$
\end{itemize}
\end{minipage}
\end{figure}
\end{mydef}
The rule $C^\neg\rightarrow \neg C$ is necessary because $C^\neg$ can be a result of $s^\neg$, where $s$ is a set term. It can be transformed into $\neg C$: For every interpretation $\sigma$ for a concept $C$ based on $QFBAPA$ we have $\sigma(C^\neg)=\sigma(\mathcal{U})\backslash \sigma(C)$ and for every interpretation $\mathcal{I}$ based on $\mathcal{ALCSCC}$ we have $(\neg C)^\mathcal{I}=\Delta^\mathcal{I}\backslash C^\mathcal{I}$. Since $\sigma(\mathcal{U})\subseteq \Delta^\mathcal{I}$ we can conclude that every element in $\sigma(C^\neg)$ is also in $(\neg C)^\mathcal{I}$.\\
The first five rules on the left hand side can be applied in linear time \cite{1},\cite{6}. The first four rules on the right hand side and the rules $C^\neg\rightarrow \neg C$ and $\neg succ(c)\rightarrow succ(\neg c)$ can also be applied in linear time since we only shift the negation sign. The rule $(s^\neg)^\neg\rightarrow s$ works similarly to $\neg\neg C\rightarrow C$ and the rules $(s\cap t)^\neg\rightarrow s^\neg\cup t^\neg$ and $(s\cup t)^\neg\rightarrow s^\neg \cap t^\neg$ works similarly to $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$ and $\neg(C\sqcap D)\rightarrow \neg C\sqcup \neg D$. Therefore all of them can also be applied in linear time.\\
Next we introduce \textit{induced interpretation} with which we can count successors of variables after any rule application and hereby detect violated assertions.
\begin{mydef}[Induced Interpretation]
An interpretation $\mathcal{I}(\mathcal{A})$ can be induced from an ABox $\mathcal{A}$ by the following steps:
\begin{itemize}
\item for each variable $x\in Var(\mathcal{A})$ we introduce $x^{\mathcal{I}(\mathcal{A})}$ and add it to $\Delta^{\mathcal{I}(\mathcal{A})}$
\item for each $x:C$ such that $C$ is a concept name we add $x^{\mathcal{I}(\mathcal{A})}$ to $C^{\mathcal{I}(\mathcal{A})}$
\item for each $(x,y):r$ such that $r$ is a role name we add $(x^{\mathcal{I}(\mathcal{A})},y^{\mathcal{I}(\mathcal{A})})$ to $r^{\mathcal{I}(\mathcal{A})}$
\end{itemize}
\end{mydef}
\begin{mydef}[Violated assertion]
Let $\mathcal{A}$ be a set of assertion, $x$ be a variable, $k$ be a cardinality term and $n\in\mathbb{N}$. An assertion $x:succ(c)$ is \textit{violated} if $x^{\mathcal{I}(\mathcal{A})}\notin succ(c)^{\mathcal{I}(\mathcal{A})}$.
\end{mydef}
Like already mentioned an ABox is unsatisfiable if all choices ends in a clash.
\begin{mydef}[Clash]
An ABox $\mathcal{A}$ contains a \textit{clash} if
\begin{itemize}
\item $\{x:\perp\}\subseteq \mathcal{A}$ or
\item $\{x:C,\,x:\neg C\}\subseteq \mathcal{A}$ or
\item $\{(x,y):r,\,(x,y):\neg r\}\subseteq \mathcal{A}$
\item $\{x:succ(c)\}\subseteq \mathcal{A}$ violated and no more rules are applicable
\end{itemize}
\end{mydef}
\subsection{Transforming an ABox into a formula}
Dealing with numerical arithmetic is challenging and hence we use the help of a $QFBAPA$ solver, whenever we want to add successors for a variable $x$. For that we collect all $succ$-assertion regarding $x$ first and then transform them into a $QFBAPA$ formula for one \textit{nested level}. We assume that the ABox is already in $NNF$. As example we look at
\begin{ex}[Example for transforming ABox into $QFBAPA$ formula]
\begin{align*}
\mathcal{A}=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|), x:succ(|A|\leq |B|), x:C\}
\end{align*}
\end{ex}
with $\mathbf{C}=\{A,B,C\}$ and $\mathbf{R}=\{r\}$
We first gather all $succ$-assertion regarding $x$ together and transform it into a formula by doing the following steps:
\begin{itemize}
\item drop all $x:succ$
\item replace all role names $r$ with $X_r$
\item replace all concepts names $C$ with $X_C$
\item replace all $succ(c)$ with $X_{c}$
\item connect all formulas with $\wedge$
\item include the conjunct $\mathcal{U}=X_{r_1}\cup\dots\cup X_{r_n}$, $r_1,\dots, r_n\in\mathbf{R}$
\end{itemize}
We replace (possible compound) concepts and role names with set variables, for which a solver can assign elements to them. The last bullet point is important because sometimes it is not explicitly stated, what kind of successor a variable has.\\
For our example we have four set variables: $X_A$, $X_B$, $X_r$ and $X_{|A|\leq |B\cap r|}$. The $QFBAPA$ formula for Example 1 is 
\begin{align}\label{f}
\phi=1\leq |X_{|A|\leq |B\cap r|}|\wedge |X_A|\leq |X_B|\wedge \mathcal{U}=X_r
\end{align}
We only replace concepts on one \textit{nested level}. In the example the first assertion tells that $x$ must have at least one successor $y$ which has more successors in $B\cap r$ than in $A$. The concept $succ(|A|\leq|B\cap r|)$ is on a different \textit{nested level} then $succ(|A|\leq |B|)$. According to one solution of the solver we can introduce variables and assertion. Also $x$ has more successor in $B$ than in $A$. By the last conjunction we give the information, that every successor must be an $r$-successor. Then in the upcoming steps we can gather all $succ$-assertion of the new variables again and repeat this step.
\subsection{Solution of a formula}
For our algorithm we assume that we have a solver, which can return all possible solutions. However there can be infinite many solutions. Actually Example 1 can have infinitetly many solutions: We can always increase the amount of successors in $B$ as long as we have fewer successors in $A$. However having a infinite solution means that the Tableau-algorithm works on a infinite space and/or does not terminate. Therefore we want to only consider solution inside some \textit{upper bounds}. For an \textit{Integer Linear Programming} (ILP) problem, which is describe as a linear system of equalities, possible upper bounds are already investigated (like in \cite{knapsack}). Therefore we want to transform our formula into a linear system of equalities in a form $Ax=b$, where $A$ and $b$ describe our cardinality constraints and $x$ is the solution e.g. denotes the numbers of elements we have to assign to set variables to satisfy the constraints:\\
First, we notice that every inequality in a QFBAPA formula can be
rewritten as $n_1\cdot|X_1|\pm \dots \pm n_i\cdot|X_i|\lesseqgtr I$, $\lesseqgtr\,\in\{\leq,\geq,=\}$, where $n_1,\dots, n_i,I\in\mathbb{Z}$ are a constants. The numbers $n_1,\dots,n_i$ are called \textit{pre-factor}. Let $c=|A|\leq |B\cap r|$. We arrange $\phi$ in \eqref{f} into
\begin{align*}
\phi=|X_{c}|\geq 1\wedge |X_A|- |X_B|\leq 0 \wedge \mathcal{U}-X_r=0
\end{align*} 
Then we change each inequalities into equalities by adding two slack variables variables $I_1$ and $I_2$:
\begin{align*}
\phi=|X_{c}|- I_1= 1\wedge |X_A|-|X_B|+I_2= 0 \wedge \mathcal{U}-X_r=0
\end{align*}
Right now it is not clear whether the set variables are overlapping or not. Therefore we consider \textit{Venn regions}, which is of the form $X^i_1\cap \dots \cap X^i_k$. The subscript $i$ denotes either $0$ or $1$. $X^0_1$ denotes $X^\neg_1$ and $X^1_1$ denotes $X_1$. Therefore we construct $A$ and $b$ such that instead of assigning elements to set variables we assign them to the Venn regions. Since we have four set variables, we have $2^4=16$ Venn region and therefore $16$ vectors denoting the Venn regions. We also have two equation which means we need at most two more vectors for the slack variables. The matrix $A$ therefore has two rows and 18 columns and $a_{ij}$, $1\leq i\leq 2$ and $1\leq j\leq 16$, denotes the sum of the pre-factors of the set variables, in which the $j$-th Venn region is included, in the $i$-th equation. We already see that the number of Venn regions grows exponentially with the number of set variables. In \cite{4} it is stated that there exists a number $N$, which is polynomial in size of $\phi$, such that at most $N$ Venn regions are not empty, if there exists a solution.
\begin{mylem}[Lemma 3 from \cite{4}]
For every $QFBAPA$ formula $\phi$ a number $N$, which is polynomial to the size of $\phi$, can be computed in polynomial time such that for every solution $\sigma$ of $\phi$ there exists a solution $\sigma^\prime$ of $\phi$ such that
\begin{itemize}
\item $|\{v|v\text{ is a Venn region and }\sigma^\prime(v)\neq \emptyset\}|\leq N$
\item $|\{v|v\text{ is a Venn region and }\sigma^\prime(v)\neq \emptyset\}|\subseteq |\{v|v\text{ is a Venn region and }\sigma^\prime(v)\neq \emptyset\}|$
\end{itemize}
\end{mylem}
Hence we guess (in non-deterministic polynomial time) a number $N$ of Venn regions, which are non-zero. In Example 1 we can already guess, that any Venn region within $X_r^\neg$ must be empty, because $\mathcal{U}=X_r$. Hence we can drop eight Venn regions and create a system of equation with $A$ being a $2\times 10$ matrix. Let the vectors for the Venn regions be in the following order:
\begin{figure}[H]
\begin{minipage}[t]{.5\textwidth}
\raggedright
\begin{itemize}
\item $v_1=X_A\cap X_B\cap X_c\cap X_r$
\item $v_2=X_A\cap X_B\cap X_c^\neg\cap X_r$
\item $v_3=X_A\cap X_B^\neg\cap X_c\cap X_r$
\item $v_4=X_A\cap X_B^\neg\cap X_c^\neg\cap X_r$
\end{itemize}
\end{minipage}% <---------------- Note the use of "%"
\begin{minipage}[t]{.5\textwidth}
\raggedleft
\begin{itemize}
\item $v_5=X_A^\neg\cap X_B\cap X_c\cap X_r$
\item $v_6=X_A^\neg\cap X_B\cap X_c^\neg\cap X_r$
\item $v_7=X_A^\neg\cap X_B^\neg\cap X_c\cap X_r$
\item $v_8=X_A^\neg\cap X_B^\neg\cap X_c^\neg\cap X_r$
\end{itemize}
\end{minipage}
\end{figure}
The last two vectors denote the slack variables: $v_9=I_1$ and $v_10=I_2$
We create now the linear system of equation:
\begin{align*}
\left ( \begin{array}{cccccccccc}
1&0&1&0&1&0&1&0&1&0\\
0&0&1&1&-1&-1&0&0&0&1
\end{array} \right )\left ( \begin{array}{c}
x_1\\x_2\\x_3\\x_4\\x_5\\x_6\\x_7\\x_8
\end{array}\right )=\left ( \begin{array}{cc}
1&0
\end{array}\right )
\end{align*}
Note that $a_{2,1}$ and $a_{2,2}$ are $0$ because the pre-factor of $X_A$ and $X_B$ in the second equation are $1$ and $-1$ and because the Venn regions $v_1$ and $v_2$ are included both in $X_A$ and $X_B$. If $x_i=0$ then the Venn region $v_i$ is empty.\\
Going back to upper bound problem: The following result from [4] can be used to establish upper bound for the solution of the \textit{ILP}:
\begin{mythe}[Theorem 1 from \cite{knapsack}]\label{upper bound}
Let $A\in \mathbb{Z}^m\times \mathbb{Z}^n$ be a matrix and $b\in\mathbb{Z}^m$ a vector. If $x\in\mathbb{N}^n$ is a solution of $Ax=b$, then there exists a solution $x^\prime$ such that all entries are integers between $0$ and $n\cdot (m\cdot max_{i,j}\{|a_{ij}|,|b_i|\})^{2\cdot m+1}$.
\end{mythe}
For finding a solution $x^\prime$ the entries of the found solution $x$ are decreased. We distinguish between two cases. Let $M=m\cdot max_{i,j}\{|a_{ij}|\}^m$, $F=\{i|x_i>M\}$ and $v_i$ be the $i$-th column of $A$
\begin{itemize}
\item If there exists integers $\alpha_i$, for all $i\in F$, such that $\sum_{i\in F}\alpha_i\cdot v_i=0$ and $\exists i: \alpha_i>0$ then $x^\prime=x-d$, $d_j=\alpha_j$ if $j\in M$ else $d_j=0$, $1\leq j\leq n$.
\item Else: There must be a vector $h\in\{0,\pm 1,\pm 2,\dots \pm M\}^m$ such that $h^T v_i\geq1, i\in F$. We premultiply $A$ and $b$ with $h^T$ for which the solution is within our bound:
\begin{align*}
h^TA x^\prime = h^Tb
\end{align*}
\end{itemize}
(proof in \cite{knapsack})\\
Therefore we are able to set an upper bound a priori for the solutions the $QFBAPA$ returns. Furthermore we stay in PSpace while calculating the upper bound by using $\leq N$ Venn regions after the results of \cite{4}.\\
In our example the upper bound for all $x_i$ is $8\cdot (2\cdot max_{i,j}\{|1|,|-1|\})^{2\cdot 2+1}=512$. Therefore we can bound our number of elements in each Venn regions to $512$. 
\subsection{Algorithm}
Finally we can present the Tableau-algorithm for an ABox in $\mathcal{ALCSCC}$. Before we handle the numerical arithmetic of $\mathcal{ALCSCC}$ we want to decompose compound concepts first. Hence we divide the algorithm in two parts: a boolean part, where the decomposing of compound concepts takes place, and a numerical part, where a part of the ABox is transformed into a $QFBAPA$ formula. Then we calculate an upper bound and let a solver return a possible solution within this bound, in case the ABox is satisfiable. The boolean part has a higher priority than the numerical part. 
\begin{mydef}[Tableau]
Let $\mathcal{A}$ be a set of assertions in $NNF$.\\
Boolean part:
\begin{itemize}
\item\label{cap} $\sqcap$-rule: $\mathcal{A}$ contains $x:C_1\sqcap C_2$ but not both $x:C_1$ and $x:C_2$\\
$\rightarrow$ $\mathcal{A}:=\mathcal{A}\cup\{x:C_1, x:C_2\}$
\item\label{cup} $\sqcup$-rule: $\mathcal{A}$ contains $x:C_1\sqcup C_2$ but neither $x:C_1$ nor $x:C_2$\\
$\rightarrow$ $\mathcal{A}:=\mathcal{A}\cup\{x:C_1\}$ or $\mathcal{A}:=\mathcal{A}\cup\{x:C_2\}$
\end{itemize}
Numerical part:
\begin{itemize}
\item\label{succ} $successor$-rule: $\mathcal{A}$ contains for a variable $x$ at least one violated assertion of the form $x:succ(c)$:
\begin{itemize}
\item gather all assertion of the form $x:succ(c)$ into a set $\mathcal{S}$
\item transform $\mathcal{S}$ into a $QFBAPA$ formula $\phi$
\item calculate the upper bound after Theorem \ref{upper bound}
\end{itemize}
If a $QFBAPA$ solver returns \textit{unsatisfiable} then $\mathcal{A}=\mathcal{A}\cup\{x:\perp\}$\\
If a $QFBAPA$ solver returns \textit{satisfiable} then select one solution $\sigma$ with in the upper bound. For each $e\in\sigma(\mathcal{U})$ we introduce a new variable $y$ and
\begin{itemize}
\item for each $e\in X_C$ we have $\mathcal{A}=\mathcal{A}\cup\{y:C\}$
\item for each $e\in X_{c}$, $c$ is a cardinality constraint, we have $\mathcal{A}=\mathcal{A}\cup\{y:succ(c)\}$
\item for each $e\in X_r$, $r\in\mathbf{R}$, we have $\mathcal{A}=\mathcal{A}\cup\{(x,y):r\}$
\end{itemize}
\end{itemize}
\end{mydef}
A \textit{complete} ABox is an ABox, on which no more rules of the Tableau-algorithm are applicable.\\
We pick up Example 1 again but in a form where it is not decomposed yet:
\begin{align*}
\mathcal{A}=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|)\sqcap succ(|A|\leq |B|)\sqcap C, (x,y):B\cap r\}
\end{align*}
We are able to apply the boolean rules and hence we apply them first and decompose into Example 1. Then we apply the $successor$-rule: We collect every $succ$-assertion regarding $x$ to a set $\mathcal{S}:=\{x:succ(1\leq|succ(|A|\leq|B\cap r|)|), x:succ(|A|\leq |B|)\}$ and convert $\mathcal{A}$ to the $QFBAPA$ formula $1\leq X_{|A|\leq|B\cap r|}\wedge|X_A|\leq |X_B|\wedge \mathcal{U}=\{X_r\}$. Then we let a solver returns an assignment if possible. In this case we see that the formula is satisfiable with $X_{|A|\leq|B\cap r|}=\{f\},X_A=\{\},X_B=\{e\}$ and $X_r=\{e,f\}$. Since we have $\mathcal{U}=\{X_r\}$ every element must be in $X_r$. That means that every successor is connected to its predecessor by a role name and in our example every successor is a $r$-successor. We then introduce for $e$ ans $f$ two variables $y$ and $z$ and the assertion $y:X_B$, $(x,y):r$, $z:succ(|A|\leq|B\cap r|)$ and $(x,z):r$ to $S$. Then for $z$ we have to apply the $successor$-rule again.
\section{Correctness}
For the correctness proof of the Tableau-algorithm we have to show that
\begin{itemize}
\item If no more rules are applicable on a clash-free ABox $\mathcal{A}$ then $\mathcal{A}$ is satisfiable
\item If $\mathcal{A}$ is satisfiable then the Tableau-algorithm terminates without a clash
\item For every input the Tableau-algorithm terminates
\end{itemize}
In all proves we assume that the $QFBAPA$ solver is correct. First we prove that the algorithm works correctly e.g. we prove the first two points. 
\begin{mylem}
If the Tableau-algorithm is applied on an ABox $\mathcal{A}=\{x:C\}$ and  terminates without a clash then $\mathcal{A}$ is satisfiable
\end{mylem}
\begin{proof}
Let $\mathcal{A}^\prime$ be the result after the algorithm terminated. Since we do not remove any assertion during the algorithm we have $\mathcal{A}\subseteq\mathcal{A}^\prime$. Hence if an interpretation $\mathcal{I}$ satisfies $\mathcal{A}^\prime$ then it also satisfies $\mathcal{A}$. Let $\mathcal{I}(\mathcal{A}^\prime)$ be the induced interpretation of $\mathcal{A}^\prime$. We show that $\mathcal{I}(\mathcal{A}^\prime)$ indeed satisfies $\mathcal{A}^\prime$ by induction over concepts:\\
For each concept name $C\in\mathbf{C}$ such that $x:C\in\mathcal{A}^\prime$, we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}$ by the definition of induced interpretation. (induction base)\\
We consider $x:C$ where $C$ is a compound concepts (induction step):
\begin{itemize}
\item $C=\neg D$: Since $\mathcal{A}^\prime$ does not contain a clash, $x:C\in A$ implies $x:D\notin A$. $D$ must be a concept name, because $\mathcal{A}^\prime$ is in $NNF$. Therefore by definition of induced interpretation and $x:D\notin A$ we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\notin D^{\mathcal{I}(\mathcal{A}^\prime)}$ which implies $x^{\mathcal{I}(\mathcal{A}^\prime)}\in \Delta^{\mathcal{I}(\mathcal{A}^\prime)}\backslash D^{\mathcal{I}(\mathcal{A}^\prime)}=C^{\mathcal{I}(\mathcal{A}^\prime)}$.
\item $C=D\sqcap E$: Since the algorithm terminated, the $\sqcap$-rule is not applicable any more. That means that there is a variable $x$, such that $\{x:D, x:E\}\subseteq \mathcal{A}^\prime$. By the induction hypothesis we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in D^{\mathcal{I}(\mathcal{A}^\prime)}$ and $x^{\mathcal{I}(\mathcal{A}^\prime)}\in E^{\mathcal{I}(\mathcal{A}^\prime)}$. Therefore $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}\cap D^{\mathcal{I}(\mathcal{A}^\prime)}=(C\sqcap D)^{\mathcal{I}(\mathcal{A}^\prime)}$.
\item $C=D\sqcup E$: Since the algorithm terminated, the $\sqcup$-rule is not applicable any more. That means that there is a variable $x$, such that $\{x:D, x:E\}\cap \mathcal{A}^\prime\neq \emptyset$. By the induction hypothesis we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in D^{\mathcal{I}(\mathcal{A}^\prime)}$ or $x^{\mathcal{I}(\mathcal{A}^\prime)}\in E^{\mathcal{I}(\mathcal{A}^\prime)}$. Therefore $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}\cup D^{\mathcal{I}(\mathcal{A}^\prime)}=(C\sqcup D)^{\mathcal{I}(\mathcal{A}^\prime)}$.
\item $C=succ(c)$: Since $\mathcal{A}^\prime$ does not contain a clash, the $QFBAPA$ solver must have returned a solution. If the solution is empty, then no variables are needed to be introduced to satisfy $x:C$ and we have $x^{\mathcal{I}(\mathcal{A}^\prime)}\in C^{\mathcal{I}(\mathcal{A}^\prime)}$. If the solution is not empty then the induced interpretation is updated by introducing a new element $y^{\mathcal{I}(\mathcal{A}^\prime)}$ for each $e\in \sigma(\mathcal{U})$ and hence also for each freshly introduced variable $y$. For each $e\in X_C$ we have $y:C\in \mathcal{A}^\prime$. By the induction hypothesis $y^{\mathcal{I}(\mathcal{A}^\prime)}$ must be in $C^{\mathcal{I}(\mathcal{A}^\prime)}$. For each $e\in X_r$ we have $(x,y):r$. By the induction step we know there must be an element $x^{\mathcal{I}(\mathcal{A}^\prime)}\in\Delta^{\mathcal{I}(\mathcal{A}^\prime)}$. Because we introduced $e$ in this step, we also introduced a new variable $y$ which means for the induced interpretation we introduce a new element $y^{\mathcal{I}(\mathcal{A}^\prime)}$. Since we also added $(x,y):r$ to $\mathcal{A}^\prime$, we must have $(x^{\mathcal{I}(\mathcal{A}^\prime)},y^{\mathcal{I}(\mathcal{A}^\prime)})\in r^{\mathcal{I}(\mathcal{A}^\prime)}$. Lastly for each $e\in X_c$, $c$ is a cardinality constraint, we have $y:succ(c)$. Again by the induction hypothesis $y^{\mathcal{I}(\mathcal{A}^\prime)}\in succ(c)^{\mathcal{I}(\mathcal{A}^\prime)}$. Since the solution is correct, we know that $x^{\mathcal{I}(\mathcal{A}^\prime)}\in succ(c)^{\mathcal{I}(\mathcal{A}^\prime)}$.
\end{itemize}
Since we know that $\mathcal{I}(\mathcal{A}^\prime)$ satisfies $\mathcal{A}^\prime$ and that $\mathcal{A}\subseteq \mathcal{A}^\prime$, $\mathcal{I}(\mathcal{A}^\prime)$ also satisfies $\mathcal{A}$.
\end{proof}
\begin{mylem}
If $\mathcal{A}:=\{x:C\}$ is satisfiable then the Tableau-algorithm terminates without a clash.
\end{mylem}
\begin{proof}
Since $\mathcal{A}$ is satisfiable it does not contain a clash. Let $\mathcal{I}=(\Delta^\mathcal{I},\cdot^\mathcal{I})$ be an interpretation, which satisfies $\mathcal{A}$. We show, that if $\mathcal{A}_i$ does not contain a clash and $\mathcal{I}$ satisfies $\mathcal{A}_i$, then $\mathcal{A}_{i+1}$ can be obtained from $\mathcal{A}_i$ by applying a rule while maintaining clash-free and satisfied by $\mathcal{I}$.\\
We already stated that $\mathcal{I}$ satisfies the clash-free $\mathcal{A}=:\mathcal{A}_{0}$. (induction base).
Let $\mathcal{A}_i$ be a clash-free ABox, which is satisfied by $\mathcal{I}$. (induction hypothesis).
We distinguish the cases based on the rules, we apply on $\mathcal{A}_i$ to obtain $\mathcal{A}_{i+1}$ (induction step):
\begin{itemize}
\item we apply the $\sqcap$-rule on $x:C\sqcap D$: The interpretation $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}:=\mathcal{A}_i\cup\{x:C,x:D\}$ because by the hypothesis $\mathcal{I}$ already satisfies $\mathcal{A}_i$ and hence also $x:C\sqcap D$. That means that $x^\mathcal{I}\in(C\sqcap D)^\mathcal{I}$ and therefore $\{x,C,x:D\}\cup\mathcal{A}_i$ is satisfied by $\mathcal{I}$
\item we apply the $\sqcup$-rule on $x:C\sqcup D$: We have to show that either $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:C\}$ or $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:D\}$ is satisfied by $\mathcal{I}$. Again by the induction hypothesis $\mathcal{A}_i$ is satisfied by $\mathcal{I}$ and hence $x^\mathcal{I}=(C\sqcup D)^\mathcal{I}$. So either we choose $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:C\}$ and hence $x^\mathcal{I}\in C^\mathcal{I}$ or we choose $\mathcal{A}_{i+1}=\mathcal{A}_i\cup\{x:D\}$ and hence $x^\mathcal{I}\in D^\mathcal{I}$. In both cases $x^\mathcal{I}\in C^\mathcal{I}\cup D^\mathcal{I}=(C\sqcup D)^\mathcal{I}$ and hence $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$.
\item we apply the $succ$-rule on $x:succ(c)$: We have to show that by this step we are able to add successors, such that $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$. In this step, we gather first all $succ$-assertion together, formulate a $QFBAPA$ formula $\phi(x)$ and let a solver return us all possible solution with in an upper bound. Because $\mathcal{A}_i$ is satisfiable, the $succ$-assertions together are also satisfiable (subset of $\mathcal{A}$). Hence there has to be solutions which can be returned by the solver. We need to show, that the solver is capable to return a solution within our upper bound, such that $\mathcal{A}_{i+1}$ is satisfied by $\mathcal{I}$. In case $x^\mathcal{I}$ has no successors, the empty solution must be a valid solution, which can be returned from the solver. If $\mathcal{I}$ is finite and within our upper bound, then we can create a solution $\sigma^\ast$ induced by $\mathcal{I}$, which can be returned by our solver. In any other case we have to show, that we can create a (finite) solution from $\mathcal{I}$, which the solver is able to return. We know that $x^\mathcal{I}$ must have a finite number of successors in $\mathcal{I}$. Therefore we can create a solution $\sigma^\ast$ based on that: Let $\sigma^\ast$ be a empty solution. For every $C\in\mathbf{C}$, $r\in\mathbf{R}$, $c$ such that $x:succ(c)\in\mathcal{A}$, let $X_C$, $X_r$, $X_c$ be set variables. For each $y^\mathcal{I}\in \bigcup_{r\in\mathbf{R}}r^\mathcal{I}(x)$ introduce an element $e$ and add it to $\sigma^\ast(\mathcal{U})$:
\begin{itemize}
\item for each $(x^\mathcal{I},y^\mathcal{I})\in r^\mathcal{I}$ add $e$ to $X_r$
\item for each $y^\mathcal{I}\in C^\mathcal{I}$ add $e$ to $X_C$
\item for each $y^\mathcal{I}\in succ(c)^\mathcal{I}$ add $e$ to $X_c$
\end{itemize}
It is clear that if the solver returns this solution then $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$ because the cardinality constraints in all $succ(c)$-assertion has to be satisfied (otherwise $\mathcal{I}$ does not satisfy $\mathcal{A}_i$). If $x^\mathcal{I}$ has more successors than the calculated upper bound, we can reduce the number of successors after \cite{knapsack}: Convert the $QFBAPA$ formula to a linear system of equations. We then create $x$: If $v_k$ is the $k$-th Venn region $X_1^i\cap\dots X_n^i$, $i\in\{0,1\}$ then let $x_k=|\{e|e\in X_1^i\cap\dots X_n^i\}|$. We know that $x$ must be a solution to the linear system because otherwise $\mathcal{I}$ does not satisfy $\mathcal{A}_i$. Then we can reduce $x$ after Theorem \ref{upper bound} to $x^\prime$. With the help of $x^\prime$ we create the new solution $\sigma$ by adding $x^\prime_k$ successors in the $k$-th Venn region. It holds for the solutions $\sigma^\ast$ and $\sigma$:
\begin{itemize}
\item $\sigma(\mathcal{U)}\subseteq\sigma^\ast(\mathcal{U})$
\item for each $e\in \sigma(\mathcal{U})$: if $\sigma(e)\in X_n, n\in\mathbf{C}\cup\mathbf{R}\cup\{c|x:succ(c)\in \mathcal{A}_i\}$ then $\sigma^\ast(e)\in X_n$
\end{itemize}
The algorithm then create variables according to the solution, which leads to the satisfaction of all $succ$-assertion of $x$. Furthermore for the induced interpretation $\mathcal{I}(\mathcal{A}_{i+1})$ we have for each freshly introduced successor $y^{\mathcal{I}(\mathcal{A}_{i+1})}$ there is an element $y^\mathcal{I}$ in $\Delta^\mathcal{I}$ such that:
\begin{itemize}
\item if $(x^{\mathcal{I}(\mathcal{A}_{i+1})},y^{\mathcal{I}(\mathcal{A}_{i+1})})\in r^{\mathcal{I}(\mathcal{A}_{i+1})}$ then $(x^{\mathcal{I}},y^{\mathcal{I}})\in r^{\mathcal{I}}$
\item if $y^{\mathcal{I}(\mathcal{A}_{i+1})}\in C^{\mathcal{I}(\mathcal{A}_{i+1})}, C\in\mathbf{C}$ then $y^\mathcal{I}\in C^\mathcal{I}$
\end{itemize}
Therefore we are able to pick a solution, such that $\mathcal{I}$ satisfies $\mathcal{A}_{i+1}$.
\end{itemize}
\end{proof}
We know that a subset of a satisfiable ABox $\mathcal{A}$ is also satisfiable because the induced interpretation $\mathcal{I}(\mathcal{A})$, which satisfies $\mathcal{A}$, satisfies all subsets of $\mathcal{A}$.\\
We now prove that the algorithm terminates. For that we define first the depth \textcolor{red}{and size?} of a concept $C$:
\begin{align*}
depth(C):=\begin{cases}
1+depth(c) & C=succ(c) \\
0 & \, \text{otherwise}
\end{cases}
\end{align*}
This function is well-define because by Definition 3 our concepts are inductively defined from concept names, hence the $depth$-function always returns an integer.
\begin{mylem}
The Tableau-algorithm always terminate for an ABox $\mathcal{A}=\{x:C\}$
\end{mylem}
\begin{proof}
???
\end{proof}
\normalem
\bibliographystyle{abbrv}
\bibliography{ref}
\end{document}
